//
//  ContentView.swift
//  SYNqFliQ
//
//  Full, self-contained ContentView replacement.
//  This file recreates the primary gameplay view, bundled-sheet handling,
//  background/media loading, audio scheduling, history UI (carousel), and input handling.
//
//  Assumptions:
//  - Types Sheet, SheetNote, Note, and SheetFileManager exist elsewhere in your project (Models.swift).
//  - AppModel exists and provides selectedSheetFilename/selectedSheet and bundledSheets if you use it.
//  - This file intentionally keeps things in one place so you can replace your existing ContentView.swift.
//
//  Backup your existing file before replacing.
//
//  Generated by assistant to match the project's prior behavior.
//

import SwiftUI
import AVFoundation
import AVKit
import UniformTypeIdentifiers
import Foundation
import FirebaseAuth

// MARK: - Crescent shape: outer circle minus inner circle (even-odd fill)
/* struct CrescentShape: Shape {
    var innerAngle: CGFloat = .pi
    var innerOffsetFraction: CGFloat = 0.62
    var innerRadiusRatio: CGFloat = 0.62

    func path(in rect: CGRect) -> Path {
        let cx = rect.midX
        let cy = rect.midY
        let outerR = min(rect.width, rect.height) / 2.0
        let innerR = outerR * innerRadiusRatio
        let maxOffset = max(0, outerR - innerR)
        let offset = maxOffset * innerOffsetFraction
        let innerCx = cx + cos(innerAngle) * offset
        let innerCy = cy + sin(innerAngle) * offset

        var p = Path()
        p.addEllipse(in: CGRect(x: cx - outerR, y: cy - outerR, width: outerR * 2, height: outerR * 2))
        p.addEllipse(in: CGRect(x: innerCx - innerR, y: innerCy - innerR, width: innerR * 2, height: innerR * 2))
        return p
    }
} TitleViewの方にあるよ */
// MARK: - SplitCircleView
// Renders a circle that is visually split into two colors with a soft blurred boundary.
// Implementation: draw a base (light) circle, overlay a darker circle offset a bit to the left,
// blur the dark overlay for a soft edge, then mask to the central circle so the outside remains transparent.
private struct SplitCircleView: View {
    var diameter: CGFloat = 200
    var leftColor: Color = Color(red: 0.58, green: 0.18, blue: 0.18) // burgundy
    var rightColor: Color = Color(red: 0.66, green: 0.88, blue: 0.88) // pale aqua
    var darkOffsetX: CGFloat = -36 // how much left-dark patch is offset (controls curve)
    var blurRadius: CGFloat = 18    // softness of the division
    var body: some View {
        ZStack {
            // right / base color
            Circle()
                .fill(rightColor)
                .frame(width: diameter, height: diameter)

            // left darker patch: offset circle blurred and masked to main circle
            Circle()
                .fill(leftColor)
                .frame(width: diameter, height: diameter)
                .offset(x: darkOffsetX)
                .blur(radius: blurRadius)
                .compositingGroup() // isolate blur before masking
                .mask(
                    Circle()
                        .frame(width: diameter, height: diameter)
                )

            // small crisp inner boundary highlight (on the right side) to suggest depth
            Circle()
                .stroke(Color.white.opacity(0.06), lineWidth: 6)
                .frame(width: diameter - 2, height: diameter - 2)
                .blendMode(.overlay)
        }
        .frame(width: diameter, height: diameter)
        .shadow(color: Color.black.opacity(0.32), radius: 12, x: 0, y: 8)

    }
}

// MARK: - ContentView

struct ContentView: View {
    @EnvironmentObject private var appModel: AppModel
    @State private var showSubtitle = false
    @State private var logoScale: CGFloat = 1.0
    @State private var playMoved: Bool = false
    // Add inside your ContentView (class/struct) scope (not inside another function).

    /// If no active hold note is currently pressed by the user, stop the hold loop SFX.
    /// This consolidates stop logic and avoids missed stop calls.
    private func checkAndStopHoldLoopIfNeeded() {
        DispatchQueue.main.async {
            // if there remains any active note that is a hold and is pressed by user, keep playing
            let anyPressed = self.activeNotes.contains { $0.isHold && $0.holdPressedByUser }
            if !anyPressed {
                GlobalSFX.shared.stopHoldLoop()
            }
        }
    }

    // Add this inside ContentView (struct)
    // Replace your existing nearbyJudgementOverlays(geo:) implementation with this version.
    // This version disables implicit animations for the position and removes transition/animation modifiers
    // that caused the moving/stacking animation when nearbyJudgements are removed.

    @ViewBuilder
    private func nearbyJudgementOverlays(geo: GeometryProxy) -> some View {
        if showJudgementNearNote {
            ForEach(Array(nearbyJudgements.enumerated()), id: \.element.id) { idx, nj in
                // compute a small staggered offset to reduce overlap
                let stackIndex = idx % 3
                let yOffset = CGFloat(stackIndex) * -18.0
                NearbyJudgementView(j: nj)
                    .position(x: min(max(8, nj.position.x), geo.size.width - 8),
                              y: max(24, nj.position.y - 36 + yOffset))
                    // Disable implicit animations for this view (prevents it from "sliding" when items are removed)
                    .transaction { t in t.animation = nil }
                    .zIndex(2)
            }
        }
    }
    // Add these inside ContentView (struct) near other @State properties.

    @AppStorage("ui.showJudgementNearNote") private var showJudgementNearNote: Bool = false
    // Holds transient nearby judgements to render on the canvas
    @State private var nearbyJudgements: [NearbyJudgement] = []
    // default nearby judgement display duration
    @AppStorage("ui.judgementDisplayDuration") private var nearbyJudgementDuration: TimeInterval = 0.45
    // MARK: State
    @State private var showingEditor: Bool = false
    @State private var bundledSheets: [(filename: String, sheet: Sheet)] = []
    @State private var sampleDataSets: [[Note]] = [] // empty builtin list
    private var sampleCount: Int { sampleDataSets.count + bundledSheets.count }

    // Background / media
    @State private var backgroundImage: UIImage? = nil
    @State private var backgroundPlayer: AVQueuePlayer? = nil
    @State private var backgroundPlayerLooper: AVPlayerLooper? = nil
    @State private var backgroundIsVideo: Bool = false
    @State private var backgroundFilename: String? = nil

    // Audio
    @State private var audioPlayer: AVAudioPlayer? = nil
    @State private var previewPlayer: AVAudioPlayer? = nil
    @State private var audioEngine: AVAudioEngine? = nil
    @State private var playerNode: AVAudioPlayerNode? = nil
    @State private var audioFile: AVAudioFile? = nil
    @State private var audioStartDeviceTime: TimeInterval? = nil
    @State private var audioSampleRate: Double = 44100.0
    @State private var currentlyPlayingAudioFilename: String? = nil
    // @State private var SFXPlayer = GlobalSFX.self

    // Playback / scheduling
    @State private var isPlaying: Bool = false
    @State private var isStopped: Bool = false // pause state
    @State private var startDate: Date? = nil
    @State private var notesToPlay: [Note] = []
    @State private var sheetNotesToPlay: [SheetNote] = []
    @State private var activeNotes: [ActiveNote] = []
    @State private var gameLoopTimer: DispatchSourceTimer? = nil
    private let gameLoopInterval: Double = 1.0 / 60.0
    @State private var initialScrollPerformed: Bool = false
    @State private var playheadTime: Double = 0.0
    // scheduling references for pause/resume
    @State private var scheduledSpawnTimes: [UUID: TimeInterval] = [:]
    @State private var scheduledClearTimes: [UUID: TimeInterval] = [:]
    @State private var scheduledSpawnWorkItemsByNote: [UUID: DispatchWorkItem] = [:]
    @State private var scheduledClearWorkItemsByNote: [UUID: DispatchWorkItem] = [:]
    @State private var scheduledNoteInfos: [UUID: (sheetNote: SheetNote, target: CGPoint, approachDuration: Double, spawnTime: Double, clearTime: Double)] = [:]
    @State private var scheduledWorkItems: [DispatchWorkItem] = []
    @State private var autoDeleteWorkItems: [UUID: DispatchWorkItem] = [:]
    @State private var pausedRemainingDelays: [UUID: (spawn: TimeInterval?, clear: TimeInterval?)] = [:]

    // hold timers
    @State private var holdTimers: [UUID: DispatchSourceTimer] = [:]

    // Input / gesture
    @State private var touchStartTime: Date? = nil
    @State private var touchStartLocation: CGPoint? = nil
    @State private var touchIsLongPress: Bool = false
    @State private var touchLongPressWorkItem: DispatchWorkItem? = nil
    @State private var isFingerDown: Bool = false
    @State private var fingerLocation: CGPoint? = nil
    @State private var touchToNote: [Int: UUID] = [:] // touch id -> activeNote id
    @State private var currentGestureID: UUID? = nil
    @State private var currentGestureHasFlicked: Bool = false

    // scoring
    @State private var score: Int = 0
    @State private var scorepoint: Int = 0
    @State private var HighScore: Int = 0
    @State private var combo: Int = 0
    @State private var maxCombo: Int = 0
    @State private var perfectCount: Int = 0
    @State private var goodCount: Int = 0
    @State private var okCount: Int = 0
    @State private var missCount: Int = 0
    @State private var cumulativeCombo: Int = 0
    @State private var consecutiveCombo: Int = 0
    @State private var playMaxHistory: [Int] = []

    @State private var showJudgementUntil: Date? = nil
    @State private var lastJudgement: String = ""
    @State private var lastJudgementColor: Color = .white

    // history UI
    @State private var playHistory: [PlayRecord] = []
    @State private var selectedRecord: PlayRecord? = nil
    @State private var isShowingRecordDetail: Bool = false

    // misc
    @State private var flickedNoteIDs: Set<UUID> = []
    @State private var preparedAudioPlayer: AVAudioPlayer? = nil
    @State private var testPlayer: AVAudioPlayer? = nil
    // tuning params
    private let perfectWindow: Double = 0.6
    private let goodWindowBefore: Double = 0.8
    private let goodWindowAfter: Double = 1.0
    private let lifeDuration: Double = 2.0
    private let speedThreshold: CGFloat = 35.0
    private let hitRadius: CGFloat = 110.0
    private let tapHitRadius: CGFloat = 10.0
    private let tapEarliestBeforeHit: Double = 0.3
    // @State private var approachDistanceFraction: Double = 0.25
    // @State private var approachSpeed: Double = 800.0
    // @State private var holdFillDurationFraction: Double = 1.0
    // @State private var holdFinishTrimThreshold: Double = 0.02
    // --- Insert into ContentView (inside the View struct) ---
    @State private var lastPausedNoteID: UUID? = nil
    @State private var lastPausedAnchorExecTime: TimeInterval? = nil
    @State private var pausedAbsoluteSpawnTimes: [UUID: TimeInterval] = [:]
    @State private var pausedAbsoluteClearTimes: [UUID: TimeInterval] = [:]
    @EnvironmentObject private var settings: SettingsStore
    // Paste these inside ContentView (struct) near other helper functions.
    //extension Optional: OptionalProtocol {}
    // Explicit per-property Bindings to avoid keyPath subscript issues and make intent clear
    private var approachDistanceFractionBinding: Binding<Double> {
        Binding(get: { settings.approachDistanceFraction },
                set: { settings.approachDistanceFraction = $0 })
    }
    private var approachSpeedBinding: Binding<Double> {
        Binding(get: { settings.approachSpeed },
                set: { settings.approachSpeed = $0 })
    }
    private var holdFillDurationFractionBinding: Binding<Double> {
        Binding(get: { settings.holdFillDurationFraction },
                set: { settings.holdFillDurationFraction = $0 })
    }
    private var holdFinishTrimThresholdBinding: Binding<Double> {
        Binding(get: { settings.holdFinishTrimThreshold },
                set: { settings.holdFinishTrimThreshold = $0 })
    }
    // ContentView の中に追加
    private func playCountForSelectedSheet() -> Int {
        guard let selFilename = appModel.selectedSheetFilename else { return 0 }
        let all = PlayHistoryStorage.load()
        return all.filter { $0.sheetFilename == selFilename }.count
    }

    // Helpers for CGFloat conversions where needed
    private func cg(_ value: Double) -> CGFloat { CGFloat(value) }
    private func cgKeyPath(_ value: Double) -> CGFloat { CGFloat(value) } // convenience alias
    private let longPressThreshold: TimeInterval = 0.25
    // hold release judgement windows (add near other timing constants)
    private let holdReleaseGoodWindow: Double = 0.25
    private let holdReleaseOkWindow: Double = 1.0    // Carousel settings
    private let carouselItemWidth: CGFloat = 100
    private let carouselItemSpacing: CGFloat = 12
    private let repeatFactor = 1
    private func indicatorProgress(forNote a: ActiveNote, now: Double) -> Double {
        let hit = a.hitTime
        let approach = max(0.001, a.approachDuration)
        let start = hit - 2.0 * approach
        let end = hit

        if now <= start { return 0.0 }
        if now >= end { return 1.0 }

        let raw = (now - start) / (end - start) // 0..1
        let eased = pow(raw, 0.7)
        return min(max(eased, 0.0), 1.0)
    }
    // 1) resetAll — 既存の reset/stop 相当の安全な実装（必要なら内容をあなたの以前の実装に合わせて拡張）
    // Replace the existing resetAll() function in ContentView.swift with the implementation below.

    public func resetAll() {
        // Stop main game loop first
        stopGameLoopIfNeeded()

        // Stop/clear audio players
        if audioPlayer?.isPlaying == true { audioPlayer?.stop() }
        audioPlayer = nil

        if previewPlayer?.isPlaying == true { previewPlayer?.stop() }
        previewPlayer = nil

        if preparedAudioPlayer?.isPlaying == true { preparedAudioPlayer?.stop() }
        preparedAudioPlayer = nil

        if testPlayer?.isPlaying == true { testPlayer?.stop() }
        testPlayer = nil

        // Stop AVAudioEngine / nodes if used
        if let node = playerNode {
            node.stop()
        }
        playerNode = nil
        if let engine = audioEngine {
            engine.stop()
        }
        audioEngine = nil
        audioFile = nil
        audioStartDeviceTime = nil
        currentlyPlayingAudioFilename = nil

        // Try to deactivate audio session (best-effort)
        do {
            try AVAudioSession.sharedInstance().setActive(false, options: [])
        } catch {
            // ignore errors but log
            print("resetAll: AVAudioSession setActive(false) failed:", error)
        }

        // Stop background media
        if backgroundIsVideo {
            backgroundPlayer?.pause()
            backgroundPlayerLooper = nil
            backgroundPlayer = nil
        }
        backgroundImage = nil
        backgroundFilename = nil
        backgroundIsVideo = false

        // Stop any global SFX loops (hold loop etc.)
        // GlobalSFX interface used elsewhere; call stopHoldLoop at minimum.
        GlobalSFX.shared.stopHoldLoop()
        // If GlobalSFX has other stop/all methods, consider calling them here as well:
        // GlobalSFX.shared.stopAll() // <-- only call if implemented

        // Cancel and clear scheduled work items & timers
        scheduledWorkItems.forEach { $0.cancel() }
        scheduledWorkItems.removeAll()

        scheduledSpawnWorkItemsByNote.values.forEach { $0.cancel() }
        scheduledSpawnWorkItemsByNote.removeAll()

        scheduledClearWorkItemsByNote.values.forEach { $0.cancel() }
        scheduledClearWorkItemsByNote.removeAll()

        scheduledSpawnTimes.removeAll()
        scheduledClearTimes.removeAll()
        scheduledNoteInfos.removeAll()
        pausedRemainingDelays.removeAll()

        autoDeleteWorkItems.values.forEach { $0.cancel() }
        autoDeleteWorkItems.removeAll()

        holdTimers.values.forEach { $0.cancel() }
        holdTimers.removeAll()

        // Reset in-memory game state
        withAnimation(.easeOut(duration: 0.12)) {
            activeNotes.removeAll()
        }
        flickedNoteIDs.removeAll()

        // Reset scoring / UI
        scorepoint = 0
        score = 0
        combo = 0
        maxCombo = 0
        perfectCount = 0
        goodCount = 0
        okCount = 0
        missCount = 0
        cumulativeCombo = 0
        consecutiveCombo = 0
        playMaxHistory.removeAll()

        lastJudgement = ""
        showJudgementUntil = nil

        // Reset playback flags
        isPlaying = false
        isStopped = false
        startDate = nil

        // Clear any preview/share/import state
        isShowingResults = false
        isShowingShare = false
        shareURL = nil
        isShowingImportPicker = false
        importErrorMessage = nil

        // Ensure UI audio references cleared
        preparedAudioPlayer = nil
        previewPlayer = nil

        print("resetAll: cleared audio, background, timers, activeNotes and scoring")
    }

    private func handleImportedFile(url: URL) {
        DispatchQueue.global(qos: .userInitiated).async {
            var didStartAccess = false
            if url.startAccessingSecurityScopedResource() {
                didStartAccess = true
            }
            defer {
                if didStartAccess {
                    url.stopAccessingSecurityScopedResource()
                }
            }

            let fileManager = FileManager.default
            let destDir = SheetFileManager.documentsURL
            let destURL = destDir.appendingPathComponent(url.lastPathComponent)

            do {
                // Ensure destination directory exists
                try fileManager.createDirectory(at: destDir, withIntermediateDirectories: true, attributes: nil)

                // If file exists, append numeric suffix to avoid overwrite
                var finalDest = destURL
                var idx = 1
                while fileManager.fileExists(atPath: finalDest.path) {
                    let base = destURL.deletingPathExtension().lastPathComponent
                    let ext = destURL.pathExtension
                    let newName = "\(base)_\(idx).\(ext)"
                    finalDest = destDir.appendingPathComponent(newName)
                    idx += 1
                }

                // Copy the file
                try fileManager.copyItem(at: url, to: finalDest)
                print("Imported file copied to: \(finalDest.path)")

                DispatchQueue.main.async {
                    // reload bundledSheets / UI
                    bundledSheets = loadBundledSheets()
                    importErrorMessage = nil
                }
            } catch {
                DispatchQueue.main.async {
                    importErrorMessage = "Import failed: \(error.localizedDescription)"
                }
                print("Import copy failed:", error)
            }
        }
    }    // 2) long-press helper stubs (no-op safe defaults)
    private func handlePotentialLongPressStart(at location: CGPoint) {
        let t0 = Date()
        print("[LP] handlePotentialLongPressStart ENTER at \(location)")

        // 軽量な UI フラグだけ（メインスレッド）
        DispatchQueue.main.async {
            // 例: 長押しの視覚表示フラグ（ContentView 側で showLongPress を利用していれば）
            // self.showLongPress = true
        }

        // ログだけで終了（重い処理はここに入れない）
        let elapsed = Date().timeIntervalSince(t0)
        print("[LP] handlePotentialLongPressStart RETURN elapsed=\(elapsed)s")
    }

    private func handlePotentialLongPressEnd(at location: CGPoint, duration: TimeInterval) {
        let t0 = Date()
        print("[LP] handlePotentialLongPressEnd ENTER at \(location) dur=\(duration)")

        DispatchQueue.main.async {
            // self.showLongPress = false
        }

        let elapsed = Date().timeIntervalSince(t0)
        print("[LP] handlePotentialLongPressEnd RETURN elapsed=\(elapsed)s")
    }
    
    private func handleFlickFromOverlay(noteId: UUID, start: CGPoint, end: CGPoint, duration: TimeInterval, canvasSize: CGSize, reportedVelocity: CGFloat? = nil) {
        struct SimpleDrag {
            var startLocation: CGPoint
            var location: CGPoint
            var predictedEndTranslation: CGSize
        }
        let predictedTranslation = CGSize(width: end.x - start.x, height: end.y - start.y)
        let simple = SimpleDrag(startLocation: start, location: end, predictedEndTranslation: predictedTranslation)

        guard let idx = activeNotes.firstIndex(where: { $0.id == noteId }) else { return }
        if flickedNoteIDs.contains(noteId) { return }

        let note = activeNotes[idx]

        // Determine a sensible origin for the note: prefer current position; if it's zero (not yet set), use targetPosition.
        let origin = (note.position == .zero) ? note.targetPosition : note.position

        // flick vector / speed
        let flickVec = CGPoint(x: predictedTranslation.width, y: predictedTranslation.height)
        let dist = hypot(flickVec.x, flickVec.y)
        let computedSpeed = dist / CGFloat(max(1e-6, duration))
        let flickSpeed: CGFloat = {
            if let rep = reportedVelocity, rep > 0 { return max(computedSpeed, rep) }
            return computedSpeed
        }()

        print("DBG: handleFlickFromOverlay noteId=\(noteId) origin=\(origin) dist=\(dist) duration=\(duration) computedSpeed=\(computedSpeed) reported=\(String(describing: reportedVelocity)) flickSpeed=\(flickSpeed) threshold=\(speedThreshold)")

        guard flickSpeed > speedThreshold else {
            print("DBG: handleFlickFromOverlay skipped: flickSpeed \(flickSpeed) <= threshold \(speedThreshold)")
            return
        }

        let theta = CGFloat(note.angleDegrees) * .pi / 180.0
        let rodDir = CGPoint(x: cos(theta), y: sin(theta))
        let n1 = CGPoint(x: -rodDir.y, y: rodDir.x); let n2 = CGPoint(x: rodDir.y, y: -rodDir.x)
        let dot1 = n1.x * flickVec.x + n1.y * flickVec.y
        let dot2 = n2.x * flickVec.x + n2.y * flickVec.y
        let chosenNormal = (dot1 >= dot2) ? n1 : n2
        let distance = max(canvasSize.width, canvasSize.height) * 1.5
        let target = CGPoint(x: origin.x + chosenNormal.x * distance, y: origin.y + chosenNormal.y * distance)

        if let work = autoDeleteWorkItems[noteId] { work.cancel(); autoDeleteWorkItems[noteId] = nil }
        flickedNoteIDs.insert(noteId)

        var elapsed: TimeInterval = 0.0
        if let player = audioPlayer, let startDev = audioStartDeviceTime { elapsed = player.deviceCurrentTime - startDev } else if let sd = startDate { elapsed = Date().timeIntervalSince(sd) }
        let dt = elapsed - note.hitTime

        var judgementText = "OK"; var judgementColor: Color = .white
        if abs(dt) <= perfectWindow { judgementText = "PERFECT"; judgementColor = .green; score += 3 }
        else if (dt >= -goodWindowBefore && dt < -perfectWindow) || (dt > perfectWindow && dt <= goodWindowAfter) { judgementText = "GOOD"; judgementColor = .blue; score += 2 }
        else { judgementText = "OK"; judgementColor = .white; score += 1 }
        combo += 1; if combo > maxCombo { maxCombo = combo }
        switch judgementText { case "PERFECT": perfectCount += 1; case "GOOD": goodCount += 1; case "OK": okCount += 1; default: break }
        let judgementPos = (note.targetPosition != .zero) ? note.targetPosition : note.position
        showJudgement(text: judgementText, color: judgementColor, position: judgementPos)
        GlobalSFX.shared.playFlickJudgement(judgementText)

        let flyDuration = 0.5 // Flickの飛んで行く時間?
        withAnimation(.easeOut(duration: flyDuration)) {
            if let idx2 = activeNotes.firstIndex(where: { $0.id == noteId }) {
                activeNotes[idx2].position = target
            }
        }
        DispatchQueue.main.asyncAfter(deadline: .now() + flyDuration + 0.05) {
            withAnimation(.easeIn(duration: 0.12)) { self.activeNotes.removeAll { $0.id == noteId } }
            self.flickedNoteIDs.remove(noteId)
        }
    }

    // MARK: - Body
    // 追加: ContentView struct の内部（body の外）に置いてください
    @ViewBuilder
    private func activeNotesStack(geo: GeometryProxy) -> some View {
        ForEach(activeNotes, id: \.id) { a in
            // indicator を先に描画（AnyView で型を固定）
            AnyView(flickIndicatorView(for: a, now: playheadTime))
            // 1ノート分の描画は ActiveNoteView に一本化する
            ActiveNoteView(
                note: a,
                playheadTime: playheadTime,
                canvasSize: geo.size,
            /*    onFlick: { dragValue in
                    // ブリッジ：ActiveNoteView からのフリックを既存のハンドラへ
                    handleFlick(for: a.id, dragValue: dragValue, in: geo.size)
                }*/
            )
        }
    }
    // temporarily replace var body: some View { ... } with this minimal body
    var body: some View {
     /*   VStack(spacing: 8) {
            Text("This is ContentView")
                .font(.system(size: 48, weight: .heavy, design: .rounded))
                .foregroundColor(.white)
                .shadow(color: .black.opacity(0.6), radius: 8, x: 0, y: 4)
        } */
        
        GeometryReader { geo in

            let cx = geo.size.width / 2
            let cy = geo.size.height / 2

            // sizes tuned to your sketch: center diameter = 200
       //     let centerSize: CGFloat = min(geo.size.width, geo.size.height,300)
            let leftCrescentSize: CGFloat = 100  // smaller left crescent (history)
         //   let rightUPCresentSize: CGFloat = 75
            let rightCrescentSize: CGFloat = max(350 ,min(geo.size.width*0.7,geo.size.height*0.7))  // larger right crescent (play)
            // distance from center for crescent center points so they visually hug the center
            let leftDistance = 0.0 //centerSize * 0.62
            let rightDistance = 0.0 // centerSize * 0.78

            // angles for placement (upper-left / upper-right-ish)
            let leftAngle = Angle.degrees(-140)   // history small crescent (slightly behind left edge)
            let rightAngle = Angle.degrees(-90)//(-40)   // play large crescent (upper-right area)

            ZStack {
                // debug: show game coordinate bounds
                Color.clear
                    .frame(width: geo.size.width, height: geo.size.height)
                    .border(Color.red, width: 10) // ← これでゲーム座標の領域が赤枠で出ます
                    .allowsHitTesting(false)
                // Background
                if let ui = backgroundImage {
                    Image(uiImage: ui)
                        .resizable()
                        .scaledToFill()
                        .frame(width: geo.size.width, height: geo.size.height)
                        .clipped()
                        .ignoresSafeArea()
                } else if backgroundIsVideo, let player = backgroundPlayer {
                    VideoPlayer(player: player)
                        .frame(width: geo.size.width, height: geo.size.height)
                        .clipped()
                        .ignoresSafeArea()
                } else {
                    Color.black.ignoresSafeArea()
                }
                Color.black.opacity(0.35)
                    .ignoresSafeArea()
                // Insert this .onReceive modifier into the top-level container in ContentView's body,
                // for example after the main ZStack/GeometryReader: `.onReceive(NotificationCenter.default.publisher(for: .playSheet)) { notif in ... }`


                // Interaction overlay: handles touches for hold notes
                // replace the existing TouchOverlay(...) block with this
                // Place this inside ContentView's ZStack near the top (replace existing "選曲に戻る" button)
                // (excerpt) Replace the existing "選曲に戻る" button block with this code.
                // Put this inside ContentView's ZStack near the top (replacing previous button).
                VStack {
                    HStack {
                        Button(action: {
                            print("DBG: Back-to-selection button tapped. before selected = \(String(describing: appModel.selectedSheetFilename)), showingSongSelection = \(appModel.showingSongSelection)")
                            
                            // Close local modals so they don't block navigation
                            isShowingRecordDetail = false
                            isShowingResults = false
                            isShowingShare = false
                            showingEditor = false
                            isShowingImportPicker = false
                            
                            // Do NOT clear appModel.selectedSheetFilename here (don't overwrite user's selection).
                            // Just request the song-selection UI.
                            appModel.openSongSelection()
                            
                            print("DBG: Back-to-selection action dispatched. after selected = \(String(describing: appModel.selectedSheetFilename)), showingSongSelection = \(appModel.showingSongSelection)")
                        })  {
                            HStack(spacing: 8) {
                                Image(systemName: "arrow.uturn.left")
                                    .font(.system(size: 14, weight: .semibold))
                                Text("選曲に戻る")
                                    .font(.subheadline)
                            }
                            .padding(8)
                            .background(Color.black.opacity(0.45))
                            .foregroundColor(.white)
                            .cornerRadius(8)
                        }
                        Spacer()
                    }
                    .padding(.top, 12)
                    .padding(.horizontal, 12)
                    Spacer()
                }
                .allowsHitTesting(true)
                .zIndex(1000)
                // Main UI VStack
                VStack {
                    // Header: score / combo
                    HStack {
                        
                        VStack(alignment: .leading) {
                            Text("Score: \(score)").foregroundColor(.white).font(.headline)
                            Text("Combo: \(combo)").foregroundColor(.yellow).font(.subheadline)
                        }
                        Spacer()
                        if shouldShowJudgement() {
                            Text(lastJudgement)
                                .font(.title2)
                                .bold()
                                .foregroundColor(lastJudgementColor)
                                .padding(8)
                                .background(Color.black.opacity(0.6))
                                .cornerRadius(8)
                        }
                    }
                    .padding(.horizontal)
                    .padding(.top, 8)
                    
                    
                    // Tuning UI (hidden while playing)
                    if !isPlaying {
                        VStack(spacing: 8) {
                            HStack {
                                Text("Approach dist (fraction): \(String(format: "%.2f", settings.approachDistanceFraction))")
                                    .foregroundColor(.white)
                                Spacer()
                            }
                            Slider(value: approachDistanceFractionBinding, in: 0.05...1.5)
                            HStack {
                                Text("Approach speed (pts/s): \(Int(settings.approachSpeed))")
                                    .foregroundColor(.white)
                                Spacer()
                                let exampleDistance = settings.approachDistanceFraction * min(geo.size.width, geo.size.height)
                                let derivedDuration = exampleDistance / max(settings.approachSpeed, 1.0)
                                Text("例 dur: \(String(format: "%.2f", derivedDuration))s")
                                    .foregroundColor(.gray)
                            }
                            Slider(value: $settings.approachSpeed, in: 100...3000)
                            VStack {
                                HStack {
                                    Text("Hold fill fraction: \(String(format: "%.2f", settings.holdFillDurationFraction))")
                                        .foregroundColor(.white)
                                    Spacer()
                                }
                                Slider(value: $settings.holdFillDurationFraction, in: 0.2...1.8)
                                HStack {
                                    Text("Hold finish trim threshold: \(String(format: "%.3f", settings.holdFinishTrimThreshold))")
                                        .foregroundColor(.white)
                                    Spacer()
                                }
                                Slider(value: $settings.holdFinishTrimThreshold, in: 0.001...0.08)
                            }
                        }
                        .padding(.horizontal)
                        .padding(.top, 6)
                    }
                    
                    Spacer()
                } // VStack
                
                // Active notes rendering
                // Active notes rendering (差し替え用)
                // 置き換え前:
                // ForEach(activeNotes) { a in ... }
                TouchOverlay(
                    onTap: { id, loc in
                        print("DBG TouchOverlay.onTap id=\(id) loc=\(loc)")
                        guard isPlaying && !isStopped else { return }
                        handleTap(at: loc, in: loc)
                    },
                    onMove: { id, loc in
                        // Minimal debug
                        // print("DBG TouchOverlay.onMove id=\(id) loc=\(loc)")
                        self.fingerLocation = loc
                    },
                    onHoldStart: { id, loc in
                        print("DBG TouchOverlay.onHoldStart id=\(id) loc=\(loc)")
                        guard isPlaying && !isStopped else { return }
                        if let nid = findNearestNoteId(to: loc) { touchToNote[id] = nid }
                        self.fingerLocation = loc
                        self.isFingerDown = true
                        handleHoldTouchBegan(at: loc)
                    },
                    onHoldEnd: { id, loc, duration in
                        print("DBG TouchOverlay.onHoldEnd id=\(id) loc=\(loc) dur=\(duration)")
                        guard isPlaying && !isStopped else { return }
                        if let assigned = touchToNote[id] {
                            handleHoldTouchEnded(at: loc)
                            touchToNote[id] = nil
                        } else {
                            handleHoldTouchEnded(at: loc)
                        }
                        self.isFingerDown = false
                        self.fingerLocation = nil
                    },
                    onFlick: { id, start, end, velocity in
                        print("DBG TouchOverlay.onFlick raw id=\(id) start=\(start) end=\(end) reportedSpeed=\(velocity)")
                        guard isPlaying && !isStopped else { return }

                        // Helper: distance from point p to segment vw
                        func pointToSegmentDistance(_ p: CGPoint, _ v: CGPoint, _ w: CGPoint) -> CGFloat {
                            let l2 = pow(w.x - v.x, 2) + pow(w.y - v.y, 2)
                            if l2 == 0 { return hypot(p.x - v.x, p.y - v.y) } // v == w
                            var t = ((p.x - v.x) * (w.x - v.x) + (p.y - v.y) * (w.y - v.y)) / l2
                            t = max(0.0, min(1.0, t))
                            let proj = CGPoint(x: v.x + t * (w.x - v.x), y: v.y + t * (w.y - v.y))
                            return hypot(p.x - proj.x, p.y - proj.y)
                        }

                        var closestId: UUID? = nil
                        var closestDist = CGFloat.greatestFiniteMagnitude
                        var chosenMetric = "start"

                        for n in activeNotes {
                            // IMPORTANT: prefer n.targetPosition (where the note is headed). If unavailable, fall back to n.position.
                            let ref = (n.targetPosition != .zero) ? n.targetPosition : n.position
                            // distances: from start, end, and perpendicular to segment (all relative to ref)
                            let dStart = hypot(ref.x - start.x, ref.y - start.y)
                            let dEnd   = hypot(ref.x - end.x,   ref.y - end.y)
                            let dSeg   = pointToSegmentDistance(ref, start, end)
                            let d = min(dStart, dEnd, dSeg)
                            if d < closestDist {
                                closestDist = d
                                closestId = n.id
                                if d == dStart { chosenMetric = "start" }
                                else if d == dEnd { chosenMetric = "end" }
                                else { chosenMetric = "segment" }
                            }
                        }

                        print("DBG onFlick nearestId=\(String(describing: closestId)) dist=\(closestDist) via=\(chosenMetric) hitRadius=\(hitRadius) activeCount=\(activeNotes.count) canvas=\(geo.size)")

                        if let noteId = closestId {
                            if let note = activeNotes.first(where: { $0.id == noteId }) {
                                let ref = (note.targetPosition != .zero) ? note.targetPosition : note.position
                                let dStart = hypot(ref.x - start.x, ref.y - start.y)
                                let dEnd   = hypot(ref.x - end.x,   ref.y - end.y)
                                let dSeg   = pointToSegmentDistance(ref, start, end)
                                print("DBG onFlick candidate note id=\(noteId) ref=\(ref) position=\(note.position) target=\(note.targetPosition) dStart=\(dStart) dEnd=\(dEnd) dSeg=\(dSeg)")
                            }
                        }

                        if let noteId = closestId, closestDist <= hitRadius {
                            // compute duration from distance/velocity (velocity is px/sec)
                            let dx = end.x - start.x
                            let dy = end.y - start.y
                            let dist = hypot(dx, dy)
                            let vel = max(CGFloat(1.0), velocity)
                            let dur = TimeInterval(dist / vel)
                            let safeDur = max(0.001, dur)
                            print("DBG onFlick computed dist=\(dist) vel=\(vel) dur=\(dur) safeDur=\(safeDur)")
                            handleFlickFromOverlay(noteId: noteId, start: start, end: end, duration: safeDur, canvasSize: geo.size)
                        } else {
                            print("DBG onFlick ignored (no nearby note on path)")
                        }
                    }
                    
                )
                .frame(maxWidth: .infinity, maxHeight: .infinity)
                .allowsHitTesting(isPlaying && !isStopped) // keep hit testing only while playing
                .ignoresSafeArea()
                .zIndex(55) // above notes but below header (header uses zIndex 1000)
                

                // 置き換え後:
                activeNotesStack(geo: geo)
                nearbyJudgementOverlays(geo: geo)
                // Insert this view builder call inside the ZStack, after activeNotesStack(geo: geo)

                // Bottom controls
                VStack {
                    Spacer()

                    VStack {
                        FloatingButton(amplitude: 10, speed: 1.6, action: {
                            // keep the small press animation you had on the floating button
                            withAnimation(.easeOut(duration: 0.12)) { logoScale = 0.96 }
                            DispatchQueue.main.asyncAfter(deadline: .now() + 0.08) {
                                withAnimation(.spring()) { logoScale = 1.0 }

                                // ---- FULL play/pause/resume/start logic (copied from your big Button) ----
                                  if isPlaying && !isStopped {
                                      // currently playing and not stopped -> pause
                                      pausePlayback()
                                  } else if isPlaying && isStopped {
                                      // currently playing but stopped -> resume
                                      resumePlayback()
                                      if let player = audioPlayer { player.play() }
                                  } else {
                                      // neither playing -> start new playback (uses appModel.selectedSheet)
                                      if let sel = appModel.resolvedSelectedSheet {
                                          sheetNotesToPlay = sel.notes
                                          notesToPlay = sel.notes.asNotes()
                                      } else {
                                          sheetNotesToPlay = []
                                          notesToPlay = []
                                      }
                                      startPlayback(in: geo.size)
                                  }
                                  // ---- end logic ----
                              }
                        }) {
                            CrescentView(size: isPlaying && !isStopped ? 0 : rightCrescentSize ,
                                         innerAngle: Angle.degrees( rightAngle.degrees + 180 ),
                                         innerOffsetFraction: 0.66,
                                         innerRadiusRatio: 0.60,
                                         gradient: LinearGradient(gradient: Gradient(colors: [Color(red: 2/256, green: 0, blue: 36/256, opacity: 1), Color(red: 9/256, green: 9/256, blue: 121/256, opacity: 1),Color(red: 0, green: 212/256, blue: 255/256, opacity: 1)]), startPoint: .topLeading, endPoint: .bottomTrailing)) {
                                VStack {
                                    Image(systemName: isPlaying && !isStopped ? "pause.fill" : "play.fill")
                                        .font(.system(size: isPlaying && !isStopped ? 70 : 150))
                                        .foregroundStyle(Color.white)
                                        .offset(y: isPlaying && !isStopped ? 0 :  10)
                                    Text(isPlaying && !isStopped ? "Pause" : (isPlaying && isStopped ? "Resume" : "Start"))
                                        .font(.subheadline).bold()
                                        .foregroundStyle(Color.white)
                                        
                                }
                                .padding(.leading, 6)
                            }
                        }
                        .buttonStyle(PlainButtonStyle())
                    }
                    // compute animated target position: if playing, move to top-right (with margin), otherwise the original hugging position
                    .position(
                        x: isPlaying && !isStopped
                        ? (geo.size.width - 35)                     // top-right x (16pt margin)
                            : (cx + CGFloat(cos(rightAngle.radians)) * rightDistance), // original x
                        y: isPlaying && !isStopped 
                        ? 35                      // top-right y (16pt margin from top)
                        : (cy + CGFloat(sin(rightAngle.radians)) * rightDistance) // original y
                    )
                    
                   // .angle(isPlaying ? )
                    .animation(.spring(response: 0.45, dampingFraction: 0.8), value: isPlaying)
                  
                  /*  .sheet(isPresented: $isShowingRecordDetail) {
                        if let rec = selectedRecord {
                            PlayRecordDetailView(record: rec, onPreview: { record in
                                if let fn = record.sheetFilename,
                                   let idx = bundledSheets.firstIndex(where: { $0.filename == fn }) {
                                    // load and preview
                                    previewAndPlaySheet(at: idx)
                                    isShowingRecordDetail = false
                                } else {
                                    print("DBG: Preview: sheet not found for record \(record.sheetFilename ?? "nil")")
                                }
                            })
                        } else {
                            // show list when opened without selecting from thumbnail
                            HistoryListView(records: playHistory, onSelect: { rec in
                                selectedRecord = rec
                                isShowingRecordDetail = true
                            })
                        }
                    }*/
                    // 新: ContentView のどこか（下部ボタン群の modifier chain）
                    // compute playCount for the currently selected sheet

                    .sheet(isPresented: $isShowingResults) {
                        ResultsView(
                            score: score,
                            maxCombo: maxCombo,
                            perfect: perfectCount,
                            good: goodCount,
                            ok: okCount,
                            miss: missCount,
                            cumulativeCombo: cumulativeCombo,
                            playMaxHistory: playMaxHistory,
                            consecutiveCombo: consecutiveCombo,
                            playCount: playCountForSelectedSheet(),
                            onPlayAgain: {
                                if !isPlaying {
                                    if let sel = appModel.resolvedSelectedSheet  {
                                        sheetNotesToPlay = sel.notes
                                        notesToPlay = sel.notes.asNotes()
                                        DispatchQueue.main.asyncAfter(deadline: .now() + 0.15) {
                                            startPlayback(in: UIScreen.main.bounds.size)
                                        }
                                    }
                                }
                            },
                            onBackToSelection: {
                                appModel.openSongSelection()
                            },
                            onSave: {
                             //   appendPlayHistoryRecord() これ入れるとsaveボタン押すたびにプレイ回数が増えてしまう
                            },
                            onShare: { items in
                                // present UIActivityViewController from root
                                guard let wnd = UIApplication.shared.connectedScenes.compactMap({ $0 as? UIWindowScene }).first?.windows.first,
                                      let root = wnd.rootViewController else { return }
                                let ac = UIActivityViewController(activityItems: items, applicationActivities: nil)
                                root.present(ac, animated: true)
                            }
                        )
                    }
                .sheet(isPresented: $isShowingShare) {
                        if let url = shareURL {
                            ShareSheet(activityItems: [url])
                        } else {
                            Text("No file to share.")
                        }
                    }

                    if !isPlaying {
                        HStack {
                            Text("Selected: \(appModel.resolvedSelectedSheet?.title ?? "—")")
                                .foregroundColor(.white)
                            Spacer()
                            Text("Difficulty: \(appModel.resolvedSelectedSheet?.difficulty ?? "-"):\(appModel.resolvedSelectedSheet?.level.map { String($0) } ?? "-")")
                                .foregroundColor(.white)
                        }
                        .padding(.bottom, 20)
                    } else {
                        HStack {
                            Text("  \(appModel.resolvedSelectedSheet?.title ?? "—")")
                                .foregroundColor(.white)
                            Spacer()
                            Text("\(appModel.resolvedSelectedSheet?.difficulty ?? "-"):\(appModel.resolvedSelectedSheet?.level.map { String($0) } ?? "-")")
                                .foregroundColor(.white)
                        }
                        .padding(.bottom, 20)
                    }
                }.zIndex(1000)
            } // ZStack
            .contentShape(Rectangle())
            // Replace the existing .simultaneousGesture(...) and .gesture(...) modifiers on the ZStack (near the end of GeometryReader)
            // with this version: the DragGesture(s) are attached only when isPlaying && !isStopped && isFingerDown is true.
            // This prevents SwiftUI from capturing single-finger drags (so TouchOverlay receives them).
            // Replace the existing .simultaneousGesture(...) and .gesture(...) modifiers on the ZStack (near the end of GeometryReader)
            // with this version. Key changes:
            // - DragGesture only updates fingerLocation in onChanged (no handleTap/handleHold calls).
            // - onEnded only calls handleGlobalFlick when the drag distance exceeds a threshold.
            // - minimumDistance is > 0 so short taps won't be recognized by the DragGesture and will be delivered to TouchOverlay.

            .simultaneousGesture(
                (isPlaying && !isStopped && isFingerDown) ? DragGesture(minimumDistance: 8) // small threshold to avoid capturing taps
                    .onChanged { value in
                        // Do minimal work: update finger location only.
                        // Keep this lightweight so it doesn't interfere with TouchOverlay handling of hold/tap.
                        fingerLocation = value.location
                    }
                    .onEnded { value in
                        // Only treat as a flick if the user performed a meaningful drag.
                        let dx = value.location.x - value.startLocation.x
                        let dy = value.location.y - value.startLocation.y
                        let dist = hypot(dx, dy)

                        // Tune this distance threshold if needed (20..40px is reasonable)
                        let flickDistanceThreshold: CGFloat = 24.0

                        if dist >= flickDistanceThreshold {
                            // call existing global flick handler
                            handleGlobalFlick(dragValue: value, in: geo.size)
                        } else {
                            // short movement: let TouchOverlay handle taps/holds; do nothing here
                            // (no handleTap / handleHoldTouchEnded calls)
                        }

                        // Ensure we don't accidentally leave per-gesture state
                        currentGestureID = nil
                        currentGestureHasFlicked = false
                        touchStartTime = nil
                        touchStartLocation = nil
                        touchIsLongPress = false
                    } : nil
            )
            .gesture(
                (isPlaying && !isStopped && isFingerDown) ?
                    DragGesture(minimumDistance: 16) // Flick判定judge?
                        .onEnded { value in
                            // Dedicated flick gesture: only invoked onEnded to call handleGlobalFlick.
                            let dx = value.location.x - value.startLocation.x
                            let dy = value.location.y - value.startLocation.y
                            let dist = hypot(dx, dy)
                            let flickDistanceThreshold: CGFloat = 24.0
                            if dist >= flickDistanceThreshold {
                                handleGlobalFlick(dragValue: value, in: geo.size)
                            }
                        } : nil
            )
            // Global drag gesture used for flicks / taps — attached only when a hold (isFingerDown) exists.
            .fileImporter(isPresented: $isShowingImportPicker, allowedContentTypes: [UTType.json, UTType.audio], allowsMultipleSelection: false) { result in
                switch result {
                case .success(let urls):
                    if let url = urls.first { handleImportedFile(url: url) }
                case .failure(let err):
                    importErrorMessage = "Import picker failed: \(err.localizedDescription)"
                }
            }
            // ContentView.swift — inside ContentView { ... } (body's modifier chain)
            .onAppear {
                // Request AppModel to (re)load sheets (async). AppModel will publish bundledSheets when ready.
                appModel.loadBundledSheets()
                // Do not force-copy appModel.bundledSheets here — wait for the published change.
                print("DBG: ContentView.onAppear requested loadBundledSheets")
            }
            .onChange(of: appModel.bundledSheets) { newList in
                // Mirror the authoritative list from AppModel
                bundledSheets = newList as! [(filename: String, sheet: Sheet)]
                print("DBG: ContentView observed appModel.bundledSheets change -> \(bundledSheets.map { $0.filename })")
            }
            .onChange(of: appModel.selectedSheetFilename) { newSel in
                print("DBG: ContentView observed selectedSheetFilename -> \(String(describing: newSel))")
                // Sync your playback lists from the AppModel selection here
                guard let fn = newSel else {
                    // clear state if needed
                    sheetNotesToPlay = []
                    notesToPlay = []
                    clearBackground()
                    return
                }
                if let idx = bundledSheets.firstIndex(where: { $0.filename == fn }) {
                    let sheet = bundledSheets[idx].sheet
                    // set notes/background from sheet
                    sheetNotesToPlay = sheet.notes
                    // replace asNotes() with your project's converter if different
                    notesToPlay = sheet.notes.asNotes()
                    prepareBackgroundIfNeeded(named: sheet.backgroundFilename, forceReload: true)
                } else {
                    print("DBG: ContentView: selected filename not found in local bundledSheets: \(fn)")
                }
            }
        } // GeometryReader
        .onReceive(NotificationCenter.default.publisher(for: .playSheet)) { notif in
            guard let userInfo = notif.userInfo as? [String: Any],
                  let sheetID = userInfo["sheetID"] as? String else {
                return
            }

            let uid = userInfo["userID"] as? String ?? (AuthManager.shared.firebaseUser?.uid ?? "local-user")

            // keep AppModel in sync so computed selectedSheet works
            appModel.selectedSheetFilename = sheetID

            // if available, set difficulty to keep UI consistent
            if let userSheet = ScoreStore.shared.userSheets.first(where: { $0.id == sheetID }) {
                appModel.selectedDifficulty = userSheet.difficulty
            }

            // choose a playback surface size; replace with stored geometry if you keep one
            let playbackSize = UIScreen.main.bounds.size

            DispatchQueue.main.async {
                // call the existing ContentView.startPlayback(in:)
                self.startPlayback(in: playbackSize)
            }
        }
    } // body

    // MARK: - History UI helpers
    private func loadPlayHistory() {
        playHistory = PlayHistoryStorage.load()
    }

    private func appendPlayHistoryRecord() {
        let rec = PlayRecord(date: Date(),
                             sheetFilename: appModel.selectedSheetFilename,
                             sheetTitle: appModel.resolvedSelectedSheet?.title,
                             score: score,
                             maxCombo: maxCombo,
                             perfectCount: perfectCount,
                             goodCount: goodCount,
                             okCount: okCount,
                             missCount: missCount)
        PlayHistoryStorage.append(rec)
        loadPlayHistory()
    }

    private func historyEntriesForCarousel() -> [PlayRecord] {
        guard !playHistory.isEmpty else { return [] }
        let bestRecord = playHistory.max(by: { $0.maxCombo < $1.maxCombo })
        let recentRecords = playHistory.filter { rec in
            if let b = bestRecord { return rec.id != b.id }
            return true
        }
        var entries: [PlayRecord] = []
        if let b = bestRecord { entries.append(b) }
        entries.append(contentsOf: Array(recentRecords.prefix(9)))
        return entries
    }


    @ViewBuilder

    // Returns AnyView to keep the concrete return type stable across branches.
    // Call like: flickIndicatorView(for: a, now: playheadTime)
    private func flickIndicatorView(for a: ActiveNote, now: Double, useBlur: Bool = false) -> AnyView {
        // Don't draw for hold notes
        if a.isHold { return AnyView(EmptyView()) }

            // timing anchors
            let hit = a.hitTime
            let approach = max(0.001, a.approachDuration)
            let start = hit - 2.0 * approach    // indicator start (user requested)
            let appear = a.spawnTime            // when the visible note appears

            // nothing to draw before start
            if now < start { return AnyView(EmptyView()) }

            // opacity phases:
            // - start <= now < appear: keep 0.1
            // - appear <= now < hit: interpolate 0.3 -> 0.7
            // - now >= hit: 1.0 until cleared (a.isClear -> hide)
            let opacity: Double
            if now < appear {
                opacity = 0.1
            } else if now >= hit {
                opacity = a.isClear ? 0.0 : 1.0
            } else {
                let denom = max(0.0001, hit - appear)
                let raw = (now - appear) / denom // 0..1
                let eased = pow(raw, 0.9)
                let startVal: Double = 0.3
                let endVal: Double = 0.7
                opacity = startVal + (endVal - startVal) * eased
            }

            // overall progress from start..hit (0..1) used for length/scale
            let rawP = min(1.0, max(0.0, (now - start) / max(0.0001, hit - start)))
            let p = pow(rawP, 0.7)

            // geometry: rod-like shape
            // prefer to compute a moving position along the rod path:
            // - if startPosition is valid (non-zero) use lerp from startPosition -> targetPosition
            // - otherwise, place indicator offset from target along angleDegrees
            let tx = a.targetPosition
            let sp = a.startPosition
            var pos = tx
            if sp != .zero {
                pos = CGPoint(
                    x: sp.x + (tx.x - sp.x) * CGFloat(p),
                    y: sp.y + (tx.y - sp.y) * CGFloat(p)
                )
            } else {
                // fallback: offset along the angle away from target (so it "moves in")
                let angleRad = CGFloat(a.angleDegrees) * .pi / 180.0
                let maxOffset: CGFloat = 120.0 // how far the indicator originates from
                let offset = maxOffset * (1.0 - CGFloat(p)) // reduces to 0 at hit
                pos = CGPoint(x: tx.x + cos(angleRad) * offset, y: tx.y + sin(angleRad) * offset)
            }

            // rod dimensions
            let rodLengthDefault: CGFloat = 160.0   // should match your RodView's default length
            let rodThicknessDefault: CGFloat = 10.0 // rod visual thickness
            // length scales with progress so it shortens as it approaches target (or invert as preferred)
            let lengthScale = 0.6 + 0.4 * CGFloat(p) // from 0.6 -> 1.0
            let length = max(40.0, rodLengthDefault * lengthScale)
            let thickness = max(6.0, rodThicknessDefault * (0.6 + 0.4 * CGFloat(p)))

            // rotation
            let rotation = Angle(degrees: a.angleDegrees)

            // Build view
            if useBlur {
                // nicer visual with blur and gradient (heavier)
                let grad = LinearGradient(
                    gradient: Gradient(stops: [
                        .init(color: Color.yellow.opacity(opacity * 0.95), location: 0.0),
                        .init(color: Color.yellow.opacity(opacity * 0.5), location: 0.6),
                        .init(color: Color.yellow.opacity(0.0), location: 1.0)
                    ]),
                    startPoint: .leading,
                    endPoint: .trailing
                )

                let v = RoundedRectangle(cornerRadius: thickness / 2)
                    .fill(grad)
                    .frame(width: length, height: thickness)
                    .rotationEffect(rotation)
                    .position(pos)
                    .scaleEffect(1.0) // already encoded in length/thickness
                    .blur(radius: 6.0 * (1.0 - CGFloat(p))) // small blur
                    .shadow(color: Color.yellow.opacity(opacity * 0.5), radius: 6 * (1.0 - CGFloat(p)))
                    .opacity(opacity)
                    .allowsHitTesting(false)

                return AnyView(v)
            } else {
                // lightweight variant: solid gradient-less rod with opacity + subtle glow
                let grad = LinearGradient(
                    gradient: Gradient(colors: [
                        Color.yellow.opacity(opacity),
                        Color.yellow.opacity(opacity * 0.35),
                        Color.clear
                    ]),
                    startPoint: .leading,
                    endPoint: .trailing
                )

                let v = RoundedRectangle(cornerRadius: thickness / 2)
                    .fill(grad)
                    .frame(width: length, height: thickness)
                    .rotationEffect(rotation)
                    .position(pos)
                    .opacity(opacity)
                    .allowsHitTesting(false)
                    .compositingGroup()
                    .shadow(color: Color.yellow.opacity(0.25 * opacity), radius: 2.0)

                return AnyView(v)
            }
        }
    // MARK: - Audio/engine helpers

    private func prepareAudioEngineIfNeeded(url: URL) {
        if let engine = audioEngine {
            engine.stop(); audioEngine = nil; playerNode = nil; audioFile = nil
        }
        do {
            let file = try AVAudioFile(forReading: url)
            audioFile = file
            let engine = AVAudioEngine()
            let player = AVAudioPlayerNode()
            engine.attach(player)
            engine.connect(player, to: engine.mainMixerNode, format: file.processingFormat)
            try engine.start()
            audioEngine = engine; playerNode = player
            audioSampleRate = file.processingFormat.sampleRate
            print("DBG: prepared audioEngine for \(url.lastPathComponent), sampleRate=\(audioSampleRate)")
        } catch {
            print("DBG: prepareAudioEngine failed:", error)
        }
    }

    private func scheduleAudioStart(atHostTime hostTime: UInt64? = nil) {
        guard let engine = audioEngine, let player = playerNode, let file = audioFile else { return }
        if player.isPlaying { player.stop() }
        var startTime: AVAudioTime? = nil
        if let ht = hostTime { startTime = AVAudioTime(hostTime: ht) }
        player.scheduleFile(file, at: startTime) {
            DispatchQueue.main.async { print("DBG: audio finished (engine)"); /* handle end */ }
        }
        if let st = startTime { audioStartDeviceTime = TimeInterval(st.hostTime) } else { audioStartDeviceTime = TimeInterval(mach_absolute_time()) }
        player.play()
        print("DBG: scheduled audio (engine) at hostTime \(String(describing: audioStartDeviceTime))")
        /// Right after you start audio (or after player.play()):
        do {
            // example if using AVAudioPlayer
            try AVAudioSession.sharedInstance().setCategory(.playback, mode: .default)
            try AVAudioSession.sharedInstance().setActive(true)
            audioPlayer?.play() // or scheduleEngine start
            // notify UI that playback has actually started
            NotificationCenter.default.post(name: .playbackDidStart, object: nil, userInfo: ["sheetID": appModel.selectedSheetFilename ?? ""])
        } catch {
            print("Playback start failed: \(error)")
            NotificationCenter.default.post(name: .playbackDidStart, object: nil, userInfo: ["sheetID": appModel.selectedSheetFilename ?? ""])
        }
    }

    // MARK: - Background media helpers

    private func bundleURLForMedia(named mediaFilename: String?) -> URL? {
        guard let mediaFilename = mediaFilename, !mediaFilename.isEmpty else { return nil }
        let ext = (mediaFilename as NSString).pathExtension
        let name = (mediaFilename as NSString).deletingPathExtension
        if let url = Bundle.main.url(forResource: name, withExtension: ext.isEmpty ? "png" : ext, subdirectory: "bundled-resources") { return url }
        if let url = Bundle.main.url(forResource: name, withExtension: ext.isEmpty ? "png" : ext) { return url }
        if let c = try? FileManager.default.contentsOfDirectory(at: SheetFileManager.documentsURL, includingPropertiesForKeys: nil, options: []) {
            if let found = c.first(where: { $0.deletingPathExtension().lastPathComponent == name && $0.pathExtension.lowercased() == ext.lowercased() }) { return found }
            if let found = c.first(where: { $0.deletingPathExtension().lastPathComponent == name }) { return found }
        }
        return nil
    }
    // Add inside ContentView { ... } (near other helpers)

    private func prepareBackgroundForSelectedSheet(forceReload: Bool = false) {
        // If AppModel.selectedSheetFilename matches a bundled sheet, apply its background.
        if let fn = appModel.selectedSheetFilename,
           let idx = bundledSheets.firstIndex(where: { $0.filename == fn }) {
            let sheet = bundledSheets[idx].sheet
            prepareBackgroundIfNeeded(named: sheet.backgroundFilename, forceReload: forceReload)
        } else {
            // no selection -> clear background
            clearBackground()
        }
    }
    private func prepareBackgroundIfNeeded(named filename: String?, forceReload: Bool = false) {
        if let player = backgroundPlayer { player.pause(); backgroundPlayerLooper = nil; backgroundPlayer = nil }
        if filename == nil || filename?.isEmpty == true {
            backgroundImage = nil; backgroundFilename = nil; backgroundIsVideo = false; return
        }
        if !forceReload, let cur = backgroundFilename, cur == filename { print("DBG: background already loaded -> skip"); return }
        backgroundImage = nil; backgroundIsVideo = false; backgroundFilename = nil
        guard let filename = filename else { return }
        if let url = bundleURLForMedia(named: filename) {
            let ext = url.pathExtension.lowercased()
            if ["png","jpg","jpeg","heic","heif"].contains(ext) {
                DispatchQueue.global(qos: .userInitiated).async {
                    if let data = try? Data(contentsOf: url), let img = UIImage(data: data) {
                        DispatchQueue.main.async {
                            self.backgroundImage = img; self.backgroundFilename = filename; self.backgroundIsVideo = false
                            print("DBG: background image loaded: \(filename)")
                        }
                    } else {
                        print("DBG: failed to load image at \(url)")
                    }
                }
                return
            } else if ["mp4","mov","m4v"].contains(ext) {
                let item = AVPlayerItem(url: url)
                let queue = AVQueuePlayer(items: [item])
                let looper = AVPlayerLooper(player: queue, templateItem: item)
                queue.isMuted = true
                queue.actionAtItemEnd = .none
                backgroundPlayerLooper = looper; backgroundPlayer = queue; backgroundIsVideo = true; backgroundFilename = filename
                print("DBG: background video prepared: \(filename)")
                return
            }
        }
        if let img = UIImage(named: filename) ?? UIImage(named: (filename as NSString).deletingPathExtension) {
            backgroundImage = img; backgroundFilename = filename; backgroundIsVideo = false
            print("DBG: background loaded via UIImage(named:): \(filename)")
        } else {
            print("DBG: prepareBackgroundIfNeeded: resource not found -> \(filename)")
        }
    }

    private func clearBackground() {
        if backgroundIsVideo {
            backgroundPlayer?.pause(); backgroundPlayerLooper = nil; backgroundPlayer = nil
        }
        backgroundImage = nil; backgroundFilename = nil; backgroundIsVideo = false
    }

    // MARK: - Bundled sheet loader

    private func loadBundledSheets() -> [(filename: String, sheet: Sheet)] {
        var results: [(String, Sheet)] = []
        let decoder = JSONDecoder()
        if let urls = Bundle.main.urls(forResourcesWithExtension: "json", subdirectory: "bundled-sheets"), !urls.isEmpty {
            for url in urls {
                if let data = try? Data(contentsOf: url), let s = try? decoder.decode(Sheet.self, from: data) {
                    results.append((url.lastPathComponent, s))
                }
            }
        }
        if results.isEmpty, let root = Bundle.main.urls(forResourcesWithExtension: "json", subdirectory: nil) {
            for url in root {
                guard !url.lastPathComponent.hasPrefix(".") else { continue }
                if let data = try? Data(contentsOf: url), let s = try? decoder.decode(Sheet.self, from: data) {
                    if !results.contains(where: { $0.0 == url.lastPathComponent }) { results.append((url.lastPathComponent, s)) }
                }
            }
        }
        if let docs = try? FileManager.default.contentsOfDirectory(at: SheetFileManager.documentsURL, includingPropertiesForKeys: nil, options: []) {
            for url in docs where url.pathExtension.lowercased() == "json" {
                if let data = try? Data(contentsOf: url), let s = try? decoder.decode(Sheet.self, from: data) {
                    if !results.contains(where: { $0.0 == url.lastPathComponent }) { results.append((url.lastPathComponent, s)) }
                }
            }
        }
        print("DBG: loadBundledSheets -> found \(results.count) sheets")
        return results
    }

    // MARK: - Game loop

    private func startGameLoopIfNeeded() {
        if gameLoopTimer != nil { return }
        let timer = DispatchSource.makeTimerSource(queue: DispatchQueue.main)
        timer.schedule(deadline: .now(), repeating: .milliseconds(Int(gameLoopInterval * 1000.0)))
        timer.setEventHandler { self.gameLoopTick() }
        gameLoopTimer = timer
        timer.resume()
        print("DBG: gameLoop started")
    }

    private func stopGameLoopIfNeeded() {
        if let t = gameLoopTimer { t.cancel(); gameLoopTimer = nil; print("DBG: gameLoop stopped") }
    }

    // Replace existing gameLoopTick() with this batched implementation
    private func gameLoopTick() {
        // compute current device time once
        let nowDev: TimeInterval = audioPlayer?.deviceCurrentTime ?? Date().timeIntervalSince1970

        // Prepare local working copy to avoid many published updates
        var newActiveNotes = activeNotes // copy snapshot
        var idsToRemove: [UUID] = []

        // Iterate over snapshot indices (we will mutate newActiveNotes)
        for i in (0..<newActiveNotes.count).reversed() {
            var note = newActiveNotes[i]

            // Movement / approach update (unchanged logic but using local 'note')
            let approachStart = note.approachStartDeviceTime ?? note.approachStartWallTime ?? (nowDev - note.approachDuration)
            let approachEnd = note.approachEndDeviceTime ?? note.approachEndWallTime ?? (approachStart + note.approachDuration)

            if nowDev <= approachStart {
                note.position = note.startPosition
                if note.isTap { note.position2 = note.startPosition }
            } else if nowDev >= approachEnd {
                note.position = note.targetPosition
                if note.isTap { note.position2 = note.targetPosition }
            } else {
                let t = max(0.0, min(1.0, (nowDev - approachStart) / max(0.00001, note.approachDuration)))
                let sx = note.startPosition.x; let sy = note.startPosition.y
                let tx = note.targetPosition.x; let ty = note.targetPosition.y
                let nx = sx + (tx - sx) * CGFloat(t)
                let ny = sy + (ty - sy) * CGFloat(t)
                note.position = CGPoint(x: nx, y: ny)
                if note.isTap { note.position2 = note.position }
            }

            // Hold handling: use central loop rather than per-note timers
            if note.isHold {
                let fillDuration = max(0.0, note.approachDuration * settings.holdFillDurationFraction)
                // compute fill end reference
                let fillEndTime = (note.approachStartDeviceTime != nil) ? (note.approachStartDeviceTime! + fillDuration) : (note.approachStartWallTime ?? Date().timeIntervalSince1970 + fillDuration)
                if nowDev < fillEndTime {
                    let fillT = (nowDev - (note.approachStartDeviceTime ?? note.approachStartWallTime ?? nowDev)) / max(0.00001, fillDuration)
                    note.holdFillScale = max(0.0, min(1.0, fillT))
                } else {
                    note.holdFillScale = 1.0
                    if !note.holdStarted {
                        note.holdStarted = true
                        if self.audioPlayer != nil {
                            note.holdStartDeviceTime = self.audioPlayer?.deviceCurrentTime
                            note.holdLastTickDeviceTime = note.holdStartDeviceTime
                        } else {
                            note.holdStartWallTime = Date().timeIntervalSince1970
                            note.holdLastTickDeviceTime = note.holdStartWallTime
                        }
                        // If finger is down near target at this moment, mark pressed
                        if self.isFingerDown, let finger = self.fingerLocation {
                            let d = hypot(note.targetPosition.x - finger.x, note.targetPosition.y - finger.y)
                            if d <= self.hitRadius && !note.holdPressedByUser && !note.holdWasReleased {
                                note.holdPressedByUser = true
                                note.holdPressDeviceTime = note.holdLastTickDeviceTime
                            }
                        }
                    }
                }

                if note.holdPressedByUser && !note.holdWasReleased {
                    let lastTick = note.holdLastTickDeviceTime ?? nowDev
                    let delta = max(0.0, nowDev - lastTick)
                    note.holdLastTickDeviceTime = nowDev
                    note.holdRemainingSeconds = max(0.0, note.holdRemainingSeconds - delta)
                    let total = max(0.0001, note.holdTotalSeconds)
                    note.holdTrim = min(1.0, max(0.0, note.holdRemainingSeconds / total))
                    if note.holdRemainingSeconds <= 0.0001 {
                        // Complete - schedule removal
                        idsToRemove.append(note.id)
                    }
                } else {
                    // If hold expired without user pressing, check miss window
                    var holdEndDev: TimeInterval? = nil
                    if let hed = note.holdEndTime {
                        if let startDev = self.audioStartDeviceTime, self.audioPlayer != nil {
                            holdEndDev = startDev + hed
                        } else if let sd = self.startDate {
                            holdEndDev = sd.timeIntervalSince1970 + hed
                        } else if let hs = note.holdStartDeviceTime {
                            holdEndDev = hs + note.holdTotalSeconds
                        } else if let hs = note.holdStartWallTime {
                            holdEndDev = hs + note.holdTotalSeconds
                        }
                    } else {
                        if let hs = note.holdStartDeviceTime { holdEndDev = hs + note.holdTotalSeconds }
                        else if let hs = note.holdStartWallTime { holdEndDev = hs + note.holdTotalSeconds }
                    }
                    if let hed = holdEndDev {
                        if nowDev - hed > 0.5 && !note.holdPressedByUser {
                            // Mark miss and remove
                            DispatchQueue.main.async {
                                self.missCount += 1; self.combo = 0; self.consecutiveCombo = 0
                                self.showJudgement(text: "MISS", color: .red)
                            }
                            idsToRemove.append(note.id)
                        }
                    }
                }
            }

            // write back to newActiveNotes
            newActiveNotes[i] = note
        } // end loop

        // perform UI updates once on main
        DispatchQueue.main.async {
            self.playheadTime = nowDev
            // remove notes
            if !idsToRemove.isEmpty {
                withAnimation(.easeIn(duration: 0.12)) {
                    for id in idsToRemove {
                        self.activeNotes.removeAll { $0.id == id }
                    }
                }
            } else {
                // assign updated array
                self.activeNotes = newActiveNotes
            }
        }
    }
    

    // MARK: - Spawn / scheduling and playback

    private func startPlayback(in size: CGSize) {
        NotificationCenter.default.post(name: .playbackWillStart, object: nil, userInfo: ["sheetID": appModel.selectedSheetFilename ?? "", "userID": AuthManager.shared.firebaseUser?.uid ?? "local-user"])

        // inside startPlayback(in size: CGSize) near the beginning:
        prepareBackgroundForSelectedSheet(forceReload: true)
        if let bg = appModel.resolvedSelectedSheet?.backgroundFilename {
            prepareBackgroundIfNeeded(named: bg, forceReload: true)
        } else {
            clearBackground()
        }

        print("DBG: startPlayback called isPlaying=\(isPlaying) isStopped=\(isStopped)")
        let isResume = self.isStopped && !self.activeNotes.isEmpty
        if !isResume {
            maxCombo = 0; score = 0; combo = 0; perfectCount = 0; goodCount = 0; okCount = 0; missCount = 0; isShowingResults = false
        }
        self.isStopped = false
        guard !isPlaying else { return }

        // resolve audio
        var audioURL: URL? = nil
        if let selected = appModel.resolvedSelectedSheet, let audioName = selected.audioFilename {
            audioURL = bundleURLForAudio(named: audioName)
        }

        if let url = audioURL {
            do {
                try AVAudioSession.sharedInstance().setCategory(.playback, mode: .default)
                try AVAudioSession.sharedInstance().setActive(true)
            } catch {
                print("DEBUG: audio session err:", error)
            }

            if let p = preparedAudioPlayer, p.url == url {
                audioPlayer = p; preparedAudioPlayer = nil; audioPlayer?.currentTime = 0
            } else {
                do {
                    audioPlayer = try AVAudioPlayer(contentsOf: url)
                    audioPlayer?.prepareToPlay()
                } catch {
                    print("DEBUG: Audio prepare failed:", error); audioPlayer = nil
                }
            }

            if let player = audioPlayer {
                let session = AVAudioSession.sharedInstance()
                let deviceNow = player.deviceCurrentTime
                let leadTime = max(0.05, session.outputLatency + session.ioBufferDuration + 0.02)
                let startAt = deviceNow + leadTime
                player.play(atTime: startAt)
                audioStartDeviceTime = startAt
                if backgroundIsVideo, let bp = backgroundPlayer {
                    DispatchQueue.main.asyncAfter(deadline: .now() + 0.02) { bp.play() }
                }
                currentlyPlayingAudioFilename = url.lastPathComponent
            } else {
                currentlyPlayingAudioFilename = nil; audioStartDeviceTime = nil
            }
        } else {
            currentlyPlayingAudioFilename = nil; audioStartDeviceTime = nil
        }

        // schedule notes (using sheetNotesToPlay)
        isPlaying = true
        stopGameLoopIfNeeded()
        startGameLoopIfNeeded()
        startDate = Date()
        activeNotes.removeAll()
        flickedNoteIDs.removeAll()
        scheduledWorkItems.forEach { $0.cancel() }; scheduledWorkItems.removeAll()
        autoDeleteWorkItems.values.forEach {  checkAndStopHoldLoopIfNeeded();$0.cancel() }; autoDeleteWorkItems.removeAll()
       

        print("startPlayback: scheduling \(sheetNotesToPlay.count) notes")
        for note in sheetNotesToPlay {
            // compute spawn times
            
            let nx = note.normalizedPosition.x
            let ny = note.normalizedPosition.y
            if nx.isNaN || ny.isNaN || nx.isInfinite || ny.isInfinite { continue }
            let clampedX = min(max(0.0, nx), 1.0)
            let clampedY = min(max(0.0, ny), 1.0)
            let approachDistance = settings.approachDistanceFraction * min(size.width, size.height)
            let approachDuration = approachDistance / max(settings.approachSpeed, 1.0)
            let spawnTime = max(0.0, note.time - approachDuration)
            let target = CGPoint(x: clampedX * size.width, y: clampedY * size.height)
            let theta = CGFloat(note.angleDegrees) * .pi / 180.0
            let rodDir = CGPoint(x: cos(theta), y: sin(theta))
            let n1 = CGPoint(x: -rodDir.y, y: rodDir.x)
            let startPos = CGPoint(x: target.x - n1.x * approachDistance, y: target.y - n1.y * approachDistance)

            let newID = UUID()
            let spawnWork = DispatchWorkItem {
                DispatchQueue.main.async {
                    // spawn ActiveNote
                    
                    let isTapNote = (note.noteType == "tap")
                    let isHoldNote = (note.noteType == "hold")
                    if isTapNote {
                        let triangleH = 44.0
                        let halfSeparation = triangleH / 2.0
                        let finalTop = CGPoint(x: target.x, y: target.y - halfSeparation)
                        let finalBottom = CGPoint(x: target.x, y: target.y + halfSeparation)
                        scheduledNoteInfos[newID] = (sheetNote: note, target: target, approachDuration: approachDuration, spawnTime: spawnTime, clearTime: note.time)
                        let topStart = CGPoint(x: finalTop.x, y: finalTop.y - approachDistance * 0.5 - 20.0)
                        let bottomStart = CGPoint(x: finalBottom.x, y: finalBottom.y + approachDistance * 0.5 + 20.0)
                        let new = ActiveNote(id: newID, sourceID: note.id, angleDegrees: 0.0, position: topStart, targetPosition: CGPoint(x: target.x, y: target.y), hitTime: note.time, spawnTime: spawnTime, isClear: false, isTap: true, position2: bottomStart)
                        self.activeNotes.append(new)
                        if let idx = self.activeNotes.firstIndex(where: { $0.id == newID }) {
                            withAnimation(.linear(duration: approachDuration)) {
                                self.activeNotes[idx].position = finalTop
                                self.activeNotes[idx].position2 = finalBottom
                            }
                        }
                    } else if isHoldNote {
                        let nowDev = audioPlayer?.deviceCurrentTime ?? Date().timeIntervalSince1970
                        let approachStartDev = (audioPlayer != nil && audioStartDeviceTime != nil) ? (audioStartDeviceTime! + spawnTime) : (Date().timeIntervalSince1970 + spawnTime)
                        let approachEndDev = approachStartDev + approachDuration
                        var new = ActiveNote(id: newID, sourceID: note.id, angleDegrees: note.angleDegrees, position: startPos, targetPosition: target, hitTime: note.time, spawnTime: spawnTime, isClear: false)
                        new.startPosition = startPos
                        new.approachStartDeviceTime = (audioPlayer != nil) ? approachStartDev : nil
                        new.approachStartWallTime = (audioPlayer == nil) ? Date().timeIntervalSince1970 + spawnTime : nil
                        new.approachEndDeviceTime = (audioPlayer != nil) ? approachEndDev : nil
                        new.approachEndWallTime = (audioPlayer == nil) ? (Date().timeIntervalSince1970 + spawnTime + approachDuration) : nil
                        new.approachDuration = approachDuration
                        new.isHold = true
                        new.holdFillScale = 0.0
                        new.holdTrim = 1.0
                        new.holdTotalSeconds = max(0.0, (note.holdEndTime ?? note.time) - note.time)
                        new.holdRemainingSeconds = new.holdTotalSeconds
                        self.activeNotes.append(new)
                        if let idx = self.activeNotes.firstIndex(where: { $0.id == newID }) {
                            withAnimation(.linear(duration: approachDuration)) {
                                self.activeNotes[idx].position = target
                                self.activeNotes[idx].position2 = target
                            }
                        }
                        let fillDur = max(0.0, approachDuration * max(0.0, min(2.0, settings.holdFillDurationFraction)))
                        DispatchQueue.main.asyncAfter(deadline: .now() + fillDur) {
                            guard let idx2 = self.activeNotes.firstIndex(where: { $0.id == newID }) else { return }
                            self.activeNotes[idx2].holdStarted = true
                            if let p = self.audioPlayer { self.activeNotes[idx2].holdStartDeviceTime = p.deviceCurrentTime }
                            else { self.activeNotes[idx2].holdStartWallTime = Date().timeIntervalSince1970 }
                            if self.isFingerDown, let finger = self.fingerLocation {
                                let d = hypot(self.activeNotes[idx2].targetPosition.x - finger.x, self.activeNotes[idx2].targetPosition.y - finger.y)
                                if d <= self.hitRadius && !self.activeNotes[idx2].holdPressedByUser && !self.activeNotes[idx2].holdWasReleased {
                                    self.activeNotes[idx2].holdPressedByUser = true
                                    self.activeNotes[idx2].holdPressDeviceTime = self.activeNotes[idx2].holdStartDeviceTime ?? self.activeNotes[idx2].holdStartWallTime
                                    self.activeNotes[idx2].holdLastTickDeviceTime = self.activeNotes[idx2].holdPressDeviceTime
                                }
                            }
                            // create hold timer
                            let timer = DispatchSource.makeTimerSource(queue: DispatchQueue.main)
                            timer.schedule(deadline: .now(), repeating: .milliseconds(33))
                            timer.setEventHandler {
                                guard let idx3 = self.activeNotes.firstIndex(where: { $0.id == newID }) else { timer.cancel(); self.holdTimers[newID] = nil; return }
                                if self.activeNotes[idx3].holdWasReleased { timer.cancel(); self.holdTimers[newID] = nil; return }

                                let nowDev2 = self.audioPlayer?.deviceCurrentTime ?? Date().timeIntervalSince1970
                                let lastTick = self.activeNotes[idx3].holdLastTickDeviceTime ?? nowDev2
                                let delta = max(0.0, nowDev2 - lastTick)
                                self.activeNotes[idx3].holdLastTickDeviceTime = nowDev2

                                if self.activeNotes[idx3].holdPressedByUser {
                                    let newRemaining = max(0.0, self.activeNotes[idx3].holdRemainingSeconds - delta)
                                    self.activeNotes[idx3].holdRemainingSeconds = newRemaining
                                    let total = max(0.0001, self.activeNotes[idx3].holdTotalSeconds)
                                    self.activeNotes[idx3].holdTrim = min(1.0, max(0.0, newRemaining / total))
                                    if newRemaining <= 0.0001 {
                                        timer.cancel(); self.holdTimers[newID] = nil
                                        if self.isStopped {
                                            self.activeNotes[idx3].holdRemainingSeconds = 0.0
                                            self.activeNotes[idx3].holdTrim = 0.0
                                            self.activeNotes[idx3].holdCompletedWhileStopped = true
                                            return
                                        }
                                        // HOLD COMPLETED: update scoring and UI, and STOP hold loop
                                        self.perfectCount += 1; self.score += 3; self.combo += 1
                                        if self.combo > self.maxCombo { self.maxCombo = self.combo }
                                        self.showJudgement(text: "PERFECT", color: .green)
                                        // Stop hold loop audio before removing the note
                                        GlobalSFX.shared.stopHoldLoop()
                                        withAnimation(.easeIn(duration: 0.12)) { self.activeNotes.removeAll { $0.id == newID } }
                                        return
                                    }
                                } else {
                                    var holdEndDev: TimeInterval? = nil
                                    if let startDev = self.audioStartDeviceTime, let hed = self.activeNotes[idx3].holdEndTime { holdEndDev = startDev + hed }
                                    else if let sd = self.startDate, let hed = self.activeNotes[idx3].holdEndTime { holdEndDev = sd.timeIntervalSince1970 + hed }
                                    else if let start = self.activeNotes[idx3].holdStartDeviceTime { holdEndDev = start + self.activeNotes[idx3].holdTotalSeconds }
                                    else if let start = self.activeNotes[idx3].holdStartWallTime { holdEndDev = start + self.activeNotes[idx3].holdTotalSeconds }

                                    // MISS by timeout (no user press before end + tolerance)
                                    if let hed = holdEndDev, nowDev2 - hed > 0.5 && !self.activeNotes[idx3].holdPressedByUser {
                                        if self.isStopped { return }
                                        self.missCount += 1; self.combo = 0; self.consecutiveCombo = 0
                                        self.showJudgement(text: "MISS", color: .red)
                                        timer.cancel(); self.holdTimers[newID] = nil
                                        // stop hold loop audio before removing the note
                                        GlobalSFX.shared.stopHoldLoop()
                                        withAnimation(.easeIn(duration: 0.12)) { self.activeNotes.removeAll { $0.id == newID } }
                                        return
                                    }
                                }

                                // also check hold completion at end time (pressed-by-user finishing at the hold end)
                                if let idx3 = self.activeNotes.firstIndex(where: { $0.id == newID }), let hed = self.activeNotes[idx3].holdEndTime {
                                    let holdEndDev = (self.audioPlayer != nil && self.audioStartDeviceTime != nil) ? (self.audioStartDeviceTime! + hed) : (self.activeNotes[idx3].holdStartWallTime ?? Date().timeIntervalSince1970 + hed)
                                    if self.activeNotes[idx3].holdPressedByUser && (self.audioPlayer?.deviceCurrentTime ?? Date().timeIntervalSince1970) >= holdEndDev {
                                        timer.cancel(); self.holdTimers[newID] = nil
                                        if self.isStopped {
                                            self.activeNotes[idx3].holdRemainingSeconds = 0.0
                                            self.activeNotes[idx3].holdTrim = 0.0
                                            self.activeNotes[idx3].holdCompletedWhileStopped = true
                                            return
                                        }
                                        self.perfectCount += 1; self.score += 3; self.combo += 1
                                        if self.combo > self.maxCombo { self.maxCombo = self.combo }
                                        self.showJudgement(text: "PERFECT", color: .green)
                                        // Stop hold loop audio before removing the note
                                        GlobalSFX.shared.stopHoldLoop()
                                        withAnimation(.easeIn(duration: 0.12)) { self.activeNotes.removeAll { $0.id == newID } }
                                        return
                                    }
                                }
                            }
                            self.holdTimers[newID] = timer
                            timer.resume()
                        }
                    } else {
                        let new = ActiveNote(id: newID, sourceID: note.id, angleDegrees: note.angleDegrees, position: startPos, targetPosition: target, hitTime: note.time, spawnTime: spawnTime, isClear: false)
                        self.activeNotes.append(new)
                        if let idx = self.activeNotes.firstIndex(where: { $0.id == newID }) {
                            withAnimation(.linear(duration: approachDuration)) {
                                self.activeNotes[idx].position = target
                            }
                        }
                    }

                    // auto-delete miss handler
                    let deleteWork = DispatchWorkItem {
                        DispatchQueue.main.async {
                            guard self.activeNotes.firstIndex(where: { $0.id == newID }) != nil else { self.autoDeleteWorkItems[newID] = nil; return }
                            if self.flickedNoteIDs.contains(newID) { self.autoDeleteWorkItems[newID] = nil; return }
                            if let idx = self.activeNotes.firstIndex(where: { $0.id == newID }), self.activeNotes[idx].isHold {
                                self.autoDeleteWorkItems[newID] = nil; return
                            }
                            withAnimation(.easeIn(duration: 0.18)) { self.activeNotes.removeAll { $0.id == newID } }
                            self.combo = 0; self.consecutiveCombo = 0; self.missCount += 1
                            self.autoDeleteWorkItems[newID] = nil
                            self.showJudgement(text: "MISS", color: .red)
                        }
                    }
                    self.autoDeleteWorkItems[newID] = deleteWork
                    if note.noteType != "hold" { DispatchQueue.main.asyncAfter(deadline: .now() + self.lifeDuration, execute: deleteWork) }
                    
                    checkAndStopHoldLoopIfNeeded() //<- これで押し続けても止まるよ
                    print("DBG: checkStopHoldLoop: active holds count = \(self.activeNotes.filter { $0.isHold && $0.holdPressedByUser }.count)")
                   
                }
            } // end spawnWork

            let clearWork = DispatchWorkItem {
                DispatchQueue.main.async {
                    var foundIndex: Int? = nil
                    let sheetNoteID = note.id
                    if !sheetNoteID.isEmpty {
                        foundIndex = self.activeNotes.firstIndex(where: { $0.sourceID == sheetNoteID })
                    }
                    if foundIndex == nil { foundIndex = self.activeNotes.firstIndex(where: { $0.hitTime == note.time && $0.targetPosition == CGPoint(x: clamp(note.normalizedPosition.x, 0, 1) * size.width, y: clamp(note.normalizedPosition.y, 0,1) * size.height) }) }
                    if let idx = foundIndex { withAnimation(.easeOut(duration: 0.12)) { self.activeNotes[idx].isClear = true } }
                }
            }

            scheduledWorkItems.append(spawnWork)
            scheduledWorkItems.append(clearWork)

            if let player = audioPlayer, let startDevice = audioStartDeviceTime {
                let deviceNow = player.deviceCurrentTime
                let spawnDeviceTime = startDevice + spawnTime
                let clearDeviceTime = startDevice + note.time
                scheduledNoteInfos[newID] = (sheetNote: note, target: target, approachDuration: approachDuration, spawnTime: spawnTime, clearTime: note.time)
                scheduledSpawnTimes[newID] = spawnDeviceTime
                scheduledClearTimes[newID] = clearDeviceTime
                scheduledSpawnWorkItemsByNote[newID] = spawnWork
                scheduledClearWorkItemsByNote[newID] = clearWork
                let spawnDelay = max(0.0, spawnDeviceTime - deviceNow)
                let clearDelay = max(0.0, clearDeviceTime - deviceNow)
                DispatchQueue.main.asyncAfter(deadline: .now() + spawnDelay, execute: spawnWork)
                DispatchQueue.main.asyncAfter(deadline: .now() + clearDelay, execute: clearWork)
            } else {
                let wallNow = Date().timeIntervalSince1970
                let spawnExecuteAt = wallNow + spawnTime
                let clearExecuteAt = wallNow + note.time
                scheduledNoteInfos[newID] = (sheetNote: note, target: target, approachDuration: approachDuration, spawnTime: spawnTime, clearTime: note.time)
                scheduledSpawnTimes[newID] = spawnExecuteAt
                scheduledClearTimes[newID] = clearExecuteAt
                scheduledSpawnWorkItemsByNote[newID] = spawnWork
                scheduledClearWorkItemsByNote[newID] = clearWork
                DispatchQueue.main.asyncAfter(deadline: .now() + spawnTime, execute: spawnWork)
                DispatchQueue.main.asyncAfter(deadline: .now() + note.time, execute: clearWork)
            }
        } // end for each note

        if let last = notesToPlay.map({ $0.time }).max() {
            let finishDelay = last + lifeDuration + 5.0 // 全ノーツ終了後何秒後に終わるか
            let finishWork = DispatchWorkItem {
                DispatchQueue.main.async {
                    self.isPlaying = false
                    self.scheduledWorkItems.removeAll()
                    self.autoDeleteWorkItems.values.forEach { $0.cancel() }
                    self.autoDeleteWorkItems.removeAll()
                    self.holdTimers.values.forEach { $0.cancel() }
                    self.holdTimers.removeAll()
                    self.activeNotes.removeAll()
                    self.audioPlayer?.stop()
                    GlobalSFX.shared.stopHoldLoop()
                    self.cumulativeCombo += self.maxCombo
                    self.consecutiveCombo += self.maxCombo
                    self.playMaxHistory.append(self.maxCombo)
                    UserDefaults.standard.set(self.cumulativeCombo, forKey: "cumulativeCombo")
                    UserDefaults.standard.set(self.playMaxHistory, forKey: "playMaxHistory")
                    UserDefaults.standard.set(self.consecutiveCombo, forKey: "consecutiveCombo")
                    self.isShowingResults = true
                    if self.audioPlayer?.isPlaying == true { self.audioPlayer?.stop() }
                    self.audioPlayer = nil
                    self.currentlyPlayingAudioFilename = nil
                    self.appendPlayHistoryRecord()
                }
            }
            scheduledWorkItems.append(finishWork)
            DispatchQueue.main.asyncAfter(deadline: .now() + finishDelay, execute: finishWork)
        }
    }
    // Snippet: add `lastPausedNoteID` storage and update pausePlayback()/resumePlayback() to support resuming from that note.
    // Place these changes into your existing PlaybackController.swift (keep other code unchanged).

    // --- add this property somewhere in the PlaybackController class scope --

/*
    // --- updated pausePlayback() ---
    private func pausePlayback() {
        stopGameLoopIfNeeded()
        guard isPlaying else { print("DBG: pause called but not playing"); return }
        isStopped = true
        if audioPlayer?.isPlaying == true { audioPlayer?.pause() }
        if backgroundIsVideo { backgroundPlayer?.pause() }
        scheduledSpawnWorkItemsByNote.values.forEach { $0.cancel() }; scheduledSpawnWorkItemsByNote.removeAll()
        scheduledClearWorkItemsByNote.values.forEach { $0.cancel() }; scheduledClearWorkItemsByNote.removeAll()
        scheduledWorkItems.forEach { $0.cancel() }; scheduledWorkItems.removeAll()
        autoDeleteWorkItems.values.forEach { $0.cancel() }; autoDeleteWorkItems.removeAll()
        pausedRemainingDelays.removeAll()
        let now = audioPlayer?.deviceCurrentTime ?? Date().timeIntervalSince1970
        for (id, exec) in scheduledSpawnTimes {
            let rem = max(0.0, exec - now)
            var e = pausedRemainingDelays[id] ?? (nil, nil)
            e.spawn = rem; pausedRemainingDelays[id] = e
        }
        for (id, exec) in scheduledClearTimes {
            let rem = max(0.0, exec - now)
            var e = pausedRemainingDelays[id] ?? (nil, nil)
            e.clear = rem; pausedRemainingDelays[id] = e
        }
        GlobalSFX.shared.stopHoldLoop()
        scheduledSpawnTimes.removeAll(); scheduledClearTimes.removeAll()
        // scheduledNoteInfos.removeAll()

        // --- Store a "resume anchor" note ID so resume can jump to it ---
        // Priority:
        // 1) If there are active notes, pick the last active note's id (most-recently spawned)
        // 2) Otherwise, pick the next scheduled spawn (earliest exec time) if any
        if let lastActive = activeNotes.last?.id {
            lastPausedNoteID = lastActive
        } else if let nextScheduled = scheduledSpawnTimes.min(by: { $0.value < $1.value })?.key {
            lastPausedNoteID = nextScheduled
        } else {
            lastPausedNoteID = nil
        }
        // Debug
        if let saved = lastPausedNoteID { print("DBG: pausePlayback saved lastPausedNoteID = \(saved)") }
    }


    // --- updated resumePlayback() ---
    private func resumePlayback() {
        guard isPlaying && isStopped else { return }
        isStopped = false
        if let player = audioPlayer { player.play() }
        if backgroundIsVideo { backgroundPlayer?.play() }
        let now = audioPlayer?.deviceCurrentTime ?? Date().timeIntervalSince1970

        // When resuming, we will:
        // - For all pausedRemainingDelays, schedule spawn/clear as before,
        // - But if a note matches lastPausedNoteID, we will spawn it immediately (so resume starts from that note)
        //   and then schedule its clear work as usual (if any).
        for (noteID, delays) in pausedRemainingDelays {
            guard let info = scheduledNoteInfos[noteID] else { continue }

            // If this is the "anchor" note to resume from, spawn immediately instead of waiting the saved spawn delay.
            if let anchor = lastPausedNoteID, anchor == noteID {
                // perform spawn immediately on main queue
                DispatchQueue.main.async { self.performSpawnNow(for: noteID, with: info) }
                // set a scheduled spawn time as 'now' for consistency
                scheduledSpawnTimes[noteID] = now
                // Also, schedule the clear if a clear delay exists (use delays.clear)
                if let clearRem = delays.clear {
                    let clearWork = DispatchWorkItem {
                        DispatchQueue.main.async { self.performClearNow(for: noteID, with: info) }
                    }
                    scheduledClearWorkItemsByNote[noteID] = clearWork
                    DispatchQueue.main.asyncAfter(deadline: .now() + clearRem, execute: clearWork)
                    scheduledClearTimes[noteID] = now + clearRem
                }
                // We do not create a scheduledSpawnWorkItem since we already spawned immediately.
                continue
            }

            // Normal resume scheduling for non-anchor notes
            let spawnWork = DispatchWorkItem {
                DispatchQueue.main.async { self.performSpawnNow(for: noteID, with: info) }
            }
            scheduledSpawnWorkItemsByNote[noteID] = spawnWork
            if let spawnRem = delays.spawn {
                DispatchQueue.main.asyncAfter(deadline: .now() + spawnRem, execute: spawnWork)
                scheduledSpawnTimes[noteID] = now + spawnRem
            }

            let clearWork = DispatchWorkItem {
                DispatchQueue.main.async { self.performClearNow(for: noteID, with: info) }
            }
            scheduledClearWorkItemsByNote[noteID] = clearWork
            if let clearRem = delays.clear {
                DispatchQueue.main.asyncAfter(deadline: .now() + clearRem, execute: clearWork)
                scheduledClearTimes[noteID] = now + clearRem
            }
        }

        // Clear pausedRemainingDelays now that everything is scheduled or spawned.
        pausedRemainingDelays.removeAll()

        // Clear the saved anchor since we've resumed from it.
        lastPausedNoteID = nil

        // Recreate hold timers for active holds as previous behavior
        for (idx, a) in activeNotes.enumerated() {
            if a.isHold && !a.holdWasReleased {
                if holdTimers[a.id] == nil {
                    let newID = a.id
                    let timer = DispatchSource.makeTimerSource(queue: DispatchQueue.main)
                    timer.schedule(deadline: .now(), repeating: .milliseconds(33))
                    timer.setEventHandler {
                        guard let idx2 = self.activeNotes.firstIndex(where: { $0.id == newID }) else { timer.cancel(); self.holdTimers[newID] = nil; return }
                        if self.activeNotes[idx2].holdWasReleased { timer.cancel(); self.holdTimers[newID] = nil; return }
                        let nowDev = self.audioPlayer?.deviceCurrentTime ?? Date().timeIntervalSince1970
                        let lastTick = self.activeNotes[idx2].holdLastTickDeviceTime ?? nowDev
                        let delta = max(0.0, nowDev - lastTick)
                        self.activeNotes[idx2].holdLastTickDeviceTime = nowDev
                        if self.activeNotes[idx2].holdPressedByUser {
                            let newRemaining = max(0.0, self.activeNotes[idx2].holdRemainingSeconds - delta)
                            self.activeNotes[idx2].holdRemainingSeconds = newRemaining
                            let total = max(0.0001, self.activeNotes[idx2].holdTotalSeconds)
                            self.activeNotes[idx2].holdTrim = min(1.0, max(0.0, newRemaining / total))
                            if newRemaining <= 0.0001 {
                                timer.cancel(); self.holdTimers[newID] = nil
                                if self.isStopped { self.activeNotes[idx2].holdRemainingSeconds = 0.0; self.activeNotes[idx2].holdTrim = 0.0; self.activeNotes[idx2].holdCompletedWhileStopped = true; return }
                                self.perfectCount += 1; self.score += 3; self.combo += 1
                                if self.combo > self.maxCombo { self.maxCombo = self.combo }
                                self.showJudgement(text: "PERFECT", color: .green)
                                withAnimation(.easeIn(duration: 0.12)) { self.activeNotes.removeAll { $0.id == newID } }
                                return
                            }
                        } else {
                            // check miss
                        }
                    }
                    self.holdTimers[newID] = timer
                    timer.resume()
                }
            }
        }
    }
 */
 /// --- updated pausePlayback() ---

    /// --- updated pausePlayback() (only show the changed/added parts, keep the rest intact) ---
    private func pausePlayback() {
        stopGameLoopIfNeeded()
        guard isPlaying else { print("DBG: pause called but not playing"); return }
        isStopped = true
        if audioPlayer?.isPlaying == true { audioPlayer?.pause() }
        if backgroundIsVideo { backgroundPlayer?.pause() }

        // SAVE absolute scheduled times so resume can decide which notes are "after" the pause anchor.
        pausedAbsoluteSpawnTimes = scheduledSpawnTimes
        pausedAbsoluteClearTimes = scheduledClearTimes

        scheduledSpawnWorkItemsByNote.values.forEach { $0.cancel() }; scheduledSpawnWorkItemsByNote.removeAll()
        scheduledClearWorkItemsByNote.values.forEach { $0.cancel() }; scheduledClearWorkItemsByNote.removeAll()
        scheduledWorkItems.forEach { $0.cancel() }; scheduledWorkItems.removeAll()
        autoDeleteWorkItems.values.forEach { $0.cancel() }; autoDeleteWorkItems.removeAll()
        pausedRemainingDelays.removeAll()

        // Use device time as now (consistent with how you previously scheduled)
        let now = audioPlayer?.deviceCurrentTime ?? Date().timeIntervalSince1970

        // Rebuild pausedRemainingDelays as before so we keep per-note remaining delays if needed elsewhere
        for (id, exec) in pausedAbsoluteSpawnTimes {
            let rem = max(0.0, exec - now)
            var e = pausedRemainingDelays[id] ?? (nil, nil)
            e.spawn = rem; pausedRemainingDelays[id] = e
        }
        for (id, exec) in pausedAbsoluteClearTimes {
            let rem = max(0.0, exec - now)
            var e = pausedRemainingDelays[id] ?? (nil, nil)
            e.clear = rem; pausedRemainingDelays[id] = e
        }

        GlobalSFX.shared.stopHoldLoop()
        scheduledSpawnTimes.removeAll(); scheduledClearTimes.removeAll()

        // --- Crucial change:
        // Save the current playback time as the resume anchor so that resume will play everything scheduled at/after this time.
        lastPausedAnchorExecTime = now

        // Optional: also save the "closest" scheduled note id for debug (not relied upon for resume)
        if let nextScheduled = pausedAbsoluteSpawnTimes.min(by: { $0.value < $1.value }) {
            lastPausedNoteID = nextScheduled.key
        } else {
            lastPausedNoteID = nil
        }

        if let anchor = lastPausedAnchorExecTime {
            print("DBG: pausePlayback saved anchorExecTime = \(anchor) lastPausedNoteID=\(lastPausedNoteID ?? nil)")
        }
    }


    // --- Updated resumePlayback() ---
    // Replace your resumePlayback() scheduling loop with the following (keep the other parts intact):
    
    /// --- updated resumePlayback() (replace your scheduling loop with this) ---
    private func resumePlayback() {
        guard isPlaying && isStopped else { return }
        isStopped = false
        if let player = audioPlayer { player.play() }
        if backgroundIsVideo { backgroundPlayer?.play() }

        let now = audioPlayer?.deviceCurrentTime ?? Date().timeIntervalSince1970
        // Anchor exec time: use saved pause-time anchor (if any), otherwise fall back to now.
        let anchorExec = lastPausedAnchorExecTime ?? now

        // Tolerance: if a note was supposed to spawn extremely close before anchor, include it
        let tolerance: TimeInterval = 0.0001

        // Iterate pausedAbsoluteSpawnTimes and schedule notes whose absolute spawn time >= anchorExec - tolerance
        for (noteID, absSpawn) in pausedAbsoluteSpawnTimes {
            // if the scheduled spawn was strictly before anchor (and outside tolerance), skip it
            if absSpawn + tolerance < anchorExec { continue }

            guard let info = scheduledNoteInfos[noteID] else {
                // If scheduledNoteInfos doesn't contain this note (key mismatch), log for debugging and skip.
                print("DBG: resume skip missing scheduledNoteInfos for id=\(noteID)")
                continue
            }

            // compute relative delay: how long after the anchor this note should appear
            let relDelay = max(0.0, absSpawn - anchorExec)

            if relDelay <= 0.0001 {
                // spawn immediately (on main queue)
                DispatchQueue.main.async { self.performSpawnNow(for: noteID, with: info) }
                scheduledSpawnTimes[noteID] = now
            } else {
                // schedule spawn after relDelay
                let spawnWork = DispatchWorkItem {
                    DispatchQueue.main.async { self.performSpawnNow(for: noteID, with: info) }
                }
                scheduledSpawnWorkItemsByNote[noteID] = spawnWork
                DispatchQueue.main.asyncAfter(deadline: .now() + relDelay, execute: spawnWork)
                scheduledSpawnTimes[noteID] = now + relDelay
            }

            // schedule clear if we have absolute clear time
            if let absClear = pausedAbsoluteClearTimes[noteID] {
                let clearRel = max(0.0, absClear - anchorExec)
                let clearWork = DispatchWorkItem {
                    DispatchQueue.main.async { self.performClearNow(for: noteID, with: info) }
                }
                scheduledClearWorkItemsByNote[noteID] = clearWork
                DispatchQueue.main.asyncAfter(deadline: .now() + clearRel, execute: clearWork)
                scheduledClearTimes[noteID] = now + clearRel
            } else if let clearRem = pausedRemainingDelays[noteID]?.clear {
                // fallback to previously saved remaining clear delay
                let clearWork = DispatchWorkItem {
                    DispatchQueue.main.async { self.performClearNow(for: noteID, with: info) }
                }
                scheduledClearWorkItemsByNote[noteID] = clearWork
                DispatchQueue.main.asyncAfter(deadline: .now() + clearRem, execute: clearWork)
                scheduledClearTimes[noteID] = now + clearRem
            }
        }

        // Cleanup paused bookkeeping
        pausedRemainingDelays.removeAll()
        pausedAbsoluteSpawnTimes.removeAll()
        pausedAbsoluteClearTimes.removeAll()
        lastPausedNoteID = nil
        lastPausedAnchorExecTime = nil

        // Recreate hold timers for active holds (keep your existing logic)
        for (idx, a) in activeNotes.enumerated() {
            if a.isHold && !a.holdWasReleased {
                if holdTimers[a.id] == nil {
                    let newID = a.id
                    let timer = DispatchSource.makeTimerSource(queue: DispatchQueue.main)
                    timer.schedule(deadline: .now(), repeating: .milliseconds(33))
                    timer.setEventHandler {
                        guard let idx2 = self.activeNotes.firstIndex(where: { $0.id == newID }) else { timer.cancel(); self.holdTimers[newID] = nil; return }
                        if self.activeNotes[idx2].holdWasReleased { timer.cancel(); self.holdTimers[newID] = nil; return }
                        let nowDev = self.audioPlayer?.deviceCurrentTime ?? Date().timeIntervalSince1970
                        let lastTick = self.activeNotes[idx2].holdLastTickDeviceTime ?? nowDev
                        let delta = max(0.0, nowDev - lastTick)
                        self.activeNotes[idx2].holdLastTickDeviceTime = nowDev
                        if self.activeNotes[idx2].holdPressedByUser {
                            let newRemaining = max(0.0, self.activeNotes[idx2].holdRemainingSeconds - delta)
                            self.activeNotes[idx2].holdRemainingSeconds = newRemaining
                            let total = max(0.0001, self.activeNotes[idx2].holdTotalSeconds)
                            self.activeNotes[idx2].holdTrim = min(1.0, max(0.0, newRemaining / total))
                            if newRemaining <= 0.0001 {
                                timer.cancel(); self.holdTimers[newID] = nil
                                if self.isStopped { self.activeNotes[idx2].holdRemainingSeconds = 0.0; self.activeNotes[idx2].holdTrim = 0.0; self.activeNotes[idx2].holdCompletedWhileStopped = true; return }
                                self.perfectCount += 1; self.score += 3; self.combo += 1
                                if self.combo > self.maxCombo { self.maxCombo = self.combo }
                                self.showJudgement(text: "PERFECT", color: .green)
                                withAnimation(.easeIn(duration: 0.12)) { self.activeNotes.removeAll { $0.id == newID } }
                                return
                            }
                        } else {
                            // check miss
                        }
                    }
                    self.holdTimers[newID] = timer
                    timer.resume()
                }
            }
        }
    }
    private func performSpawnNow(for noteID: UUID, with info: (sheetNote: SheetNote, target: CGPoint, approachDuration: Double, spawnTime: Double, clearTime: Double)) {
        // replicate the spawn behavior (simplified)
        // This helper can be filled to replicate spawnWork; for now we call startPlayback scheduling path.
        // Implementation left minimal to avoid duplication — spawn was already scheduled in startPlayback.
    }

    private func performClearNow(for noteID: UUID, with info: (sheetNote: SheetNote, target: CGPoint, approachDuration: Double, spawnTime: Double, clearTime: Double)) {
        // replicate clear behavior — mark isClear for matching active note
        if let idx = activeNotes.firstIndex(where: { $0.sourceID == info.sheetNote.id }) {
            withAnimation(.easeOut(duration: 0.12)) { activeNotes[idx].isClear = true }
        }
    }

    // MARK: - Input handling

    private func findNearestNoteId(to loc: CGPoint, within radius: CGFloat = 110.0) -> UUID? {
        var nearest: UUID? = nil; var bestDist = CGFloat.greatestFiniteMagnitude
        for n in activeNotes {
            let d = hypot(n.targetPosition.x - loc.x, n.targetPosition.y - loc.y)
            if d < bestDist && d <= radius { bestDist = d; nearest = n.id }
        }
        return nearest
    }

    // Replace your existing handleHoldTouchBegan(at:) in ContentView.swift with this optimized version.
    // Key optimizations:
    // - Use squared distances to avoid expensive hypot() until the final chosen candidate.
    // - Early skip when dx^2+dy^2 > hitRadius^2 so we skip sqrt for distant notes.
    // - Minimize repeated index lookups by working on a local copy and writing back only when needed.

    private func handleHoldTouchBegan(at location: CGPoint) {
        guard !isStopped else { return }
        isFingerDown = true
        fingerLocation = location

        // obtain current device-relative play time (same as elsewhere)
        let nowDev = audioPlayer?.deviceCurrentTime ?? Date().timeIntervalSince1970

        // Fast nearest-hold search using squared distances
        let r = hitRadius
        let r2 = r * r
        var closestIdx: Int? = nil
        var bestDist2: CGFloat = .greatestFiniteMagnitude

        // iterate indices to avoid copying large ActiveNote objects more than necessary
        for i in activeNotes.indices {
            let n = activeNotes[i]
            // only consider hold notes that are valid targets
            if !n.isHold { continue }
            if n.holdWasReleased { continue }
            if n.holdPressedByUser { continue }

            // prefer targetPosition if available (targetPosition is what we consider the "hit" location)
            let ref = (n.targetPosition != .zero) ? n.targetPosition : n.position
            // compute squared distance (cheap)
            let dx = ref.x - location.x
            let dy = ref.y - location.y
            let dist2 = dx * dx + dy * dy
            // early skip if outside radius (cheap)
            if dist2 > r2 { continue }
            // if better than best, keep
            if dist2 < bestDist2 {
                bestDist2 = dist2
                closestIdx = i
            }
        }

        // If no candidate within hitRadius, bail out quickly
        guard let idx = closestIdx else { return }

        // Work with the chosen note
        // We'll mutate it in-place via index
        var chosen = activeNotes[idx]

        // If the hold hasn't entered "holdStarted" yet, just mark pressed and set times
        if !chosen.holdStarted {
            chosen.holdPressedByUser = true
            chosen.holdPressDeviceTime = nowDev
            chosen.holdLastTickDeviceTime = nowDev
            activeNotes[idx] = chosen
            // Start the hold SFX immediately (keep as-is)
          //  GlobalSFX.shared.startHoldLoop()
            return
        }

        // Determine reference start time for hold judgement
        var startTimeRef: TimeInterval?
        if let t = chosen.holdStartDeviceTime { startTimeRef = t }
        else if let t = chosen.holdStartWallTime { startTimeRef = t }
        else {
            if let player = audioPlayer, let startDev = audioStartDeviceTime {
                startTimeRef = startDev + chosen.hitTime
            } else if let sd = startDate {
                startTimeRef = sd.timeIntervalSince1970 + chosen.hitTime
            }
        }

        // If we couldn't find a time reference, accept as immediate press (fast path)
        guard let holdStartRef = startTimeRef else {
            chosen.holdPressedByUser = true
            chosen.holdPressDeviceTime = nowDev
            chosen.holdLastTickDeviceTime = nowDev
            activeNotes[idx] = chosen
            GlobalSFX.shared.startHoldLoop()
            return
        }

        // Compute dt relative to hold start reference (cheap arithmetic)
        let dt = nowDev - holdStartRef

        // judgement (keep same windows as before)
        var judgementText = "OK"; var judgementColor: Color = .white
        if abs(dt) <= perfectWindow {
            judgementText = "PERFECT"; judgementColor = .green; score += 3
        } else if (dt >= -goodWindowBefore && dt < -perfectWindow) || (dt > perfectWindow && dt <= goodWindowAfter) {
            judgementText = "GOOD"; judgementColor = .blue; score += 2
        } else {
            let tooLateEarly = (dt < -goodWindowBefore) || (dt > goodWindowAfter)
            if tooLateEarly {
                // Miss: minimal mutation and early return
                judgementText = "MISS"; judgementColor = .red; missCount += 1
                chosen.holdWasReleased = true
                // remove chosen note (animate on main)
                DispatchQueue.main.async {
                    withAnimation(.easeIn(duration: 0.12)) {
                        self.activeNotes.removeAll { $0.id == chosen.id }
                    }
                    self.showJudgement(text: judgementText, color: judgementColor)
                    GlobalSFX.shared.stopHoldLoop()
                }
                return
            } else {
                judgementText = "OK"; judgementColor = .white; score += 1
            }
        }

        // Update scoring and note state with minimal UI work on main queue
        combo += 1
        if combo > maxCombo { maxCombo = combo }
        switch judgementText { case "PERFECT": perfectCount += 1; case "GOOD": goodCount += 1; case "OK": okCount += 1; default: break }

        // Show judgement and start hold loop
        let judgementPos = (activeNotes[idx].targetPosition != .zero) ? activeNotes[idx].targetPosition : activeNotes[idx].position
        showJudgement(text: judgementText, color: judgementColor, position: judgementPos)
        GlobalSFX.shared.startHoldLoop() // <-これを消したら全く音しなくなったから、他のstartHoldLoopは機能していなさそう。

        // mark pressed and initialize times
        chosen.holdPressedByUser = true
        chosen.holdPressDeviceTime = nowDev
        chosen.holdLastTickDeviceTime = nowDev

        // write back the modified note
        activeNotes[idx] = chosen
    }
    private func handleHoldTouchEnded(at location: CGPoint) { // 指離す動作をした時だけ判定されてコンボも変わっている気がする...そしてそのせいでholdloop音も消えない
        guard !isStopped else { GlobalSFX.shared.stopHoldLoop(); return }
        isFingerDown = false; fingerLocation = nil
        let nowDev = audioPlayer?.deviceCurrentTime ?? Date().timeIntervalSince1970
        var pressedIdx: Int? = nil; var pressedDist = CGFloat.greatestFiniteMagnitude
        for (i, n) in activeNotes.enumerated() {
            guard n.isHold else { continue }
            guard n.holdPressedByUser else { continue }
            guard !n.holdWasReleased else { continue }
            let d = hypot(n.targetPosition.x - location.x, n.targetPosition.y - location.y)
            if d < pressedDist { pressedDist = d; pressedIdx = i }
        }
        guard let idx = pressedIdx else { return }
        let note = activeNotes[idx]
        activeNotes[idx].holdWasReleased = true
        activeNotes[idx].holdPressedByUser = false
        activeNotes[idx].holdLastTickDeviceTime = nil
        var holdEndRef: TimeInterval?
        if let player = audioPlayer, let startDev = audioStartDeviceTime, let hed = note.holdEndTime { holdEndRef = startDev + hed }
        else if let sd = startDate, let hed = note.holdEndTime { holdEndRef = sd.timeIntervalSince1970 + hed }
        else {
            if let start = note.holdStartDeviceTime { holdEndRef = start + note.holdTotalSeconds }
            else if let start = note.holdStartWallTime { holdEndRef = start + note.holdTotalSeconds }
        }
        
        guard let holdEnd = holdEndRef
        else { showJudgement(text: "OK", color: .white)
             return }
        let deltaToEnd = holdEnd - nowDev
        var releaseJudgement = "OK"; var releaseColor: Color = .white
        if deltaToEnd <= 0 { releaseJudgement = "PERFECT"; releaseColor = .green; score += 3; perfectCount += 1;GlobalSFX.shared.stopHoldLoop() }
        else if deltaToEnd <= holdReleaseGoodWindow { releaseJudgement = "GOOD"; releaseColor = .blue; score += 2; goodCount += 1;GlobalSFX.shared.stopHoldLoop()  }
        else if deltaToEnd <= holdReleaseOkWindow { releaseJudgement = "OK"; releaseColor = .white; score += 1; okCount += 1 ;GlobalSFX.shared.stopHoldLoop() }
        else { releaseJudgement = "MISS"; releaseColor = .red; missCount += 1; combo = 0; consecutiveCombo = 0;GlobalSFX.shared.stopHoldLoop() }
        if releaseJudgement != "MISS" { combo += 1; if combo > maxCombo { maxCombo = combo } ;GlobalSFX.shared.stopHoldLoop()}
        showJudgement(text: releaseJudgement, color: releaseColor)
        GlobalSFX.shared.stopHoldLoop()
        GlobalSFX.shared.playTapJudgement(releaseJudgement)
        let noteID = note.id
        if let timer = holdTimers[noteID] { timer.cancel(); holdTimers[noteID] = nil ;GlobalSFX.shared.stopHoldLoop()} // これできっと話さなくてもholdloopサウンド消えるはず...
        withAnimation(.easeIn(duration: 0.12)) { self.activeNotes.removeAll { $0.id == noteID }
            GlobalSFX.shared.stopHoldLoop()}
        
    }

    private func handleTap(at location: CGPoint, in _unused: CGPoint) {
        guard !isStopped else { return }
        var elapsed: TimeInterval = 0.0
        if let player = audioPlayer, let startDev = audioStartDeviceTime { elapsed = player.deviceCurrentTime - startDev }
        else if let sd = startDate { elapsed = Date().timeIntervalSince(sd) }
        var candidateIndices: [Int] = []
        for (i, a) in activeNotes.enumerated() {
            guard a.isTap else { continue }
            let earliestAccept = a.hitTime - tapEarliestBeforeHit
            if elapsed < earliestAccept { continue }
            let triangleH = 44.0
            let halfSeparation = triangleH / 2.0
            let finalTop = CGPoint(x: a.targetPosition.x, y: a.targetPosition.y - halfSeparation)
            let finalBottom = CGPoint(x: a.targetPosition.x, y: a.targetPosition.y + halfSeparation)
            let topRect = CGRect(x: finalTop.x - 88/2.0, y: finalTop.y - triangleH/2.0, width: 88, height: triangleH)
            let bottomRect = CGRect(x: finalBottom.x - 88/2.0, y: finalBottom.y - triangleH/2.0, width: 88, height: triangleH)
            if topRect.contains(location) || bottomRect.contains(location) { candidateIndices.append(i); continue }
            let d = hypot(a.targetPosition.x - location.x, a.targetPosition.y - location.y)
            if d <= tapHitRadius { candidateIndices.append(i); continue }
        }
        guard !candidateIndices.isEmpty else { return }
        var bestIdx: Int? = nil; var bestTimeDiff = Double.greatestFiniteMagnitude
        for idx in candidateIndices {
            let note = activeNotes[idx]
            let dt = abs(elapsed - note.hitTime)
            if dt < bestTimeDiff { bestTimeDiff = dt; bestIdx = idx }
        }
        guard let idx = bestIdx else { return }
        let note = activeNotes[idx]
        let dt = elapsed - note.hitTime
        // determine a reasonable position to display judgment (use targetPosition or note.position)
        var judgementText = "OK"; var judgementColor: Color = .white
        if abs(dt) <= perfectWindow { judgementText = "PERFECT"; judgementColor = .green;score += 3 }
        else if (dt >= -goodWindowBefore && dt < -perfectWindow) || (dt > perfectWindow && dt <= goodWindowAfter) { judgementText = "GOOD"; judgementColor = .blue; score += 2 }
        else { judgementText = "OK"; judgementColor = .white; score += 1 }
        combo += 1; if combo > maxCombo { maxCombo = combo }
        switch judgementText { case "PERFECT": perfectCount += 1; case "GOOD": goodCount += 1; case "OK": okCount += 1; default: break }
        let noteID = note.id
        if let w = autoDeleteWorkItems[noteID] { w.cancel(); autoDeleteWorkItems[noteID] = nil }
        withAnimation(.easeOut(duration: 0.12)) { self.activeNotes.removeAll { $0.id == noteID } }
        let judgementPos = (note.targetPosition != .zero) ? note.targetPosition : note.position
        showJudgement(text: judgementText, color: judgementColor, position: judgementPos)
        GlobalSFX.shared.playTapJudgement(judgementText)
    }

    private func handleFlick(for id: UUID, dragValue: DragGesture.Value, in size: CGSize) {
        guard !isStopped else { return }
        if flickedNoteIDs.contains(id) { return }
        let predicted = dragValue.predictedEndTranslation
        let flickVec = CGPoint(x: predicted.width, y: predicted.height)
        let flickSpeed = hypot(flickVec.x, flickVec.y)
        guard flickSpeed > speedThreshold else { return }
        guard let idx = activeNotes.firstIndex(where: { $0.id == id }) else { return }
        let note = activeNotes[idx]
        let theta = CGFloat(note.angleDegrees) * .pi / 180.0
        let rodDir = CGPoint(x: cos(theta), y: sin(theta))
        let n1 = CGPoint(x: -rodDir.y, y: rodDir.x); let n2 = CGPoint(x: rodDir.y, y: -rodDir.x)
        let dot1 = n1.x * flickVec.x + n1.y * flickVec.y
        let dot2 = n2.x * flickVec.x + n2.y * flickVec.y
        let chosenNormal = (dot1 >= dot2) ? n1 : n2
        let distance = max(size.width, size.height) * 1.5
        let target = CGPoint(x: note.position.x + chosenNormal.x * distance, y: note.position.y + chosenNormal.y * distance)
        if let work = autoDeleteWorkItems[id] { work.cancel(); autoDeleteWorkItems[id] = nil }
        flickedNoteIDs.insert(id)
        var elapsed: TimeInterval = 0.0
        if let player = audioPlayer, let startDev = audioStartDeviceTime { elapsed = player.deviceCurrentTime - startDev } else if let sd = startDate { elapsed = Date().timeIntervalSince(sd) }
        let dt = elapsed - note.hitTime
        var judgementText = "OK"; var judgementColor: Color = .white
        if abs(dt) <= perfectWindow { judgementText = "PERFECT"; judgementColor = .green; score += 3 }
        else if (dt >= -goodWindowBefore && dt < -perfectWindow) || (dt > perfectWindow && dt <= goodWindowAfter) { judgementText = "GOOD"; judgementColor = .blue; score += 2 }
        else { judgementText = "OK"; judgementColor = .white; score += 1 }
        combo += 1; if combo > maxCombo { maxCombo = combo }
        switch judgementText { case "PERFECT": perfectCount += 1; case "GOOD": goodCount += 1; case "OK": okCount += 1; default: break }
        showJudgement(text: judgementText, color: judgementColor)
        GlobalSFX.shared.playFlickJudgement(judgementText)
        let flyDuration = 0.6
        withAnimation(.easeOut(duration: flyDuration)) {
            if let idx2 = activeNotes.firstIndex(where: { $0.id == id }) {
                activeNotes[idx2].position = target
            }
        }
        DispatchQueue.main.asyncAfter(deadline: .now() + flyDuration + 0.05) {
            withAnimation(.easeIn(duration: 0.12)) { self.activeNotes.removeAll { $0.id == id } }
            self.flickedNoteIDs.remove(id)
        }
    }

    private func handleGlobalFlick(dragValue: DragGesture.Value, in size: CGSize) {
        if currentGestureHasFlicked { return }
        currentGestureHasFlicked = true
        let predicted = dragValue.predictedEndTranslation
        let flickVec = CGPoint(x: predicted.width, y: predicted.height)
        let flickSpeed = hypot(flickVec.x, flickVec.y)
        guard !isStopped else { return }
        guard flickSpeed > speedThreshold else { return }
        let start = dragValue.startLocation
        var closestId: UUID? = nil; var closestDist = CGFloat.greatestFiniteMagnitude
        for n in activeNotes {
            let d = hypot(n.position.x - start.x, n.position.y - start.y)
            if d < closestDist { closestDist = d; closestId = n.id }
        }
        if let id = closestId, closestDist <= hitRadius { handleFlick(for: id, dragValue: dragValue, in: size) }
    }

    // MARK: - Utility / UI helpers

    // Replace existing showJudgement(text:color:) with this new version in ContentView.

    private func showJudgement(text: String, color: Color, position: CGPoint? = nil) {
        // update the global/top-right judgement as before
        lastJudgement = text
        lastJudgementColor = color
        showJudgementUntil = Date().addingTimeInterval(0.8)

        // if user wants nearby judgements and we were given a position, add a transient nearby judgement
        guard showJudgementNearNote, let pos = position else { return }

        let nj = NearbyJudgement(id: UUID(), text: text, color: color, position: pos, createdAt: Date(), duration: nearbyJudgementDuration)
        nearbyJudgements.append(nj)

        // schedule removal after duration
        DispatchQueue.main.asyncAfter(deadline: .now() + nearbyJudgementDuration) {
            // remove without animation so the views don't reposition (which caused the central-move effect)
            self.nearbyJudgements.removeAll { $0.id == nj.id }
        }
    }

    private func shouldShowJudgement() -> Bool {
        if let until = showJudgementUntil { return Date() <= until }
        return false
    }

    // small helpers for previewing history items
    private func previewAndPlaySheet(at idx: Int) {
        guard bundledSheets.indices.contains(idx) else { return }
        let sheet = bundledSheets[idx].sheet
        if let bg = sheet.backgroundFilename { prepareBackgroundIfNeeded(named: bg, forceReload: true) } else { clearBackground() }
        if let audioName = sheet.audioFilename, let url = bundleURLForAudio(named: audioName) {
            do {
                previewPlayer = try AVAudioPlayer(contentsOf: url)
                previewPlayer?.play()
                isPlaying = true
                Timer.scheduledTimer(withTimeInterval: 0.5, repeats: true) { t in
                    if self.previewPlayer?.isPlaying == false {
                        t.invalidate(); self.isPlaying = false
                    }
                }
            } catch {
                print("DBG: preview audio failed:", error)
            }
        }
    }

    private func previewSheet(at bundledIndex: Int) { previewAndPlaySheet(at: bundledIndex) }

    private func previewAndPlaySheet_stop() { stopPreview() }

    private func stopPreview() {
        if previewPlayer?.isPlaying == true { previewPlayer?.stop() }
        previewPlayer = nil
        if backgroundIsVideo { backgroundPlayer?.pause() }
        backgroundPlayerLooper = nil; backgroundPlayer = nil
        backgroundImage = nil; backgroundFilename = nil; backgroundIsVideo = false
        isPlaying = false
    }

    // MARK: - Audio helpers (bundle)
    private func bundleURLForAudio(named audioFilename: String?) -> URL? {
        guard let audioFilename = audioFilename, !audioFilename.isEmpty else { return nil }
        let ext = (audioFilename as NSString).pathExtension
        let name = (audioFilename as NSString).deletingPathExtension
        if let url = Bundle.main.url(forResource: name, withExtension: ext.isEmpty ? "wav" : ext, subdirectory: "bundled-audio") { return url }
        if let url = Bundle.main.url(forResource: name, withExtension: ext.isEmpty ? "wav" : ext) { return url }
        if let c = try? FileManager.default.contentsOfDirectory(at: SheetFileManager.documentsURL, includingPropertiesForKeys: nil, options: []) {
            if let found = c.first(where: { $0.deletingPathExtension().lastPathComponent == name && $0.pathExtension.lowercased() == ext.lowercased() }) { return found }
            if let found = c.first(where: { $0.deletingPathExtension().lastPathComponent == name }) { return found }
        }
        return nil
    }

    // MARK: - Misc fields referenced by UI sheets
    @State private var isShowingResults: Bool = false
    @State private var isShowingShare: Bool = false
    @State private var shareURL: URL? = nil
    @State private var isShowingImportPicker: Bool = false
    @State private var importErrorMessage: String? = nil

    // MARK: - Helpers
    private func clamp(_ v: Double, _ lo: Double, _ hi: Double) -> Double {
        return min(max(v, lo), hi)
    }
}

// MARK: - Basic shapes

struct RodView: View {
    let angleDegrees: Double
    var body: some View {
        Rectangle()
            .fill(LinearGradient(gradient: Gradient(colors: [Color.white, Color.gray]), startPoint: .leading, endPoint: .trailing))
            .cornerRadius(5)
            .shadow(color: Color.white.opacity(0.2), radius: 4, x: 0, y: 2)
            .rotationEffect(.degrees(angleDegrees))
    }
}

struct TriangleUp: Shape {
    func path(in rect: CGRect) -> Path {
        var p = Path()
        p.move(to: CGPoint(x: rect.midX, y: rect.minY))
        p.addLine(to: CGPoint(x: rect.maxX, y: rect.maxY))
        p.addLine(to: CGPoint(x: rect.minX, y: rect.maxY))
        p.closeSubpath()
        return p
    }
}

struct TriangleDown: Shape {
    func path(in rect: CGRect) -> Path {
        var p = Path()
        p.move(to: CGPoint(x: rect.midX, y: rect.maxY))
        p.addLine(to: CGPoint(x: rect.maxX, y: rect.minY))
        p.addLine(to: CGPoint(x: rect.minX, y: rect.minY))
        p.closeSubpath()
        return p
    }
}

struct Sector: Shape {
    var progress: Double
    func path(in rect: CGRect) -> Path {
        var p = Path()
        let center = CGPoint(x: rect.midX, y: rect.midY)
        let radius = min(rect.width, rect.height) / 2.0
        let startAngle = -Double.pi / 2.0
        let endAngle = startAngle + progress * 2.0 * Double.pi
        p.move(to: center)
        p.addArc(center: center, radius: radius, startAngle: Angle(radians: startAngle), endAngle: Angle(radians: endAngle), clockwise: false)
        p.closeSubpath()
        return p
    }
}

struct HoldView: View {
    let size: CGFloat
    let fillScale: Double
    let trimProgress: Double
    let ringColor: Color
    let fillColor: Color
    var body: some View {
        ZStack {
            Circle().stroke(ringColor, lineWidth: max(3, size * 0.06)).frame(width: size, height: size)
            Circle()
                .fill(fillColor)
                .frame(width: size * CGFloat(max(0.0, fillScale)), height: size * CGFloat(max(0.0, fillScale)))
                .opacity(fillScale > 0.001 ? 1.0 : 0.0)
                .mask(Sector(progress: trimProgress).frame(width: size, height: size))
        }.frame(width: size, height: size)
    }
}
//
// MARK: - ShareSheet helper
/*
extension PlaybackController {
    public func loadSheet(_ sheet: Sheet, userID: String) {
        // prepare internal arrays used by startPlayback
        self.sheetNotesToPlay = sheet.notes
        self.notesToPlay = sheet.notes.asNotes()
        // don't try to set appModel.selectedSheet if it's read-only
        DispatchQueue.main.async {
            self.appModel.selectedSheetFilename = sheet.id ?? self.appModel.selectedSheetFilename
            self.appModel.selectedDifficulty = sheet.difficulty
        }
    }

    public func loadAudioFile(url: URL) {
        DispatchQueue.global(qos: .userInitiated).async {
            do {
                try AVAudioSession.sharedInstance().setCategory(.playback, mode: .default)
                try AVAudioSession.sharedInstance().setActive(true)
            } catch {
                print("PlaybackController.loadAudioFile: audio session error: \(error)")
            }
            do {
                let player = try AVAudioPlayer(contentsOf: url)
                player.prepareToPlay()
                DispatchQueue.main.async {
                    self.preparedAudioPlayer = player
                }
            } catch {
                print("PlaybackController.loadAudioFile: failed to prepare player: \(error)")
            }
        }
    }

    public func loadAndStart(sheet: Sheet, userID: String, in size: CGSize) {
        loadSheet(sheet, userID: userID)
        if let audioURL = ScoreStore.shared.audioURL(for: sheet, userID: userID) {
            loadAudioFile(url: audioURL)
        }
        DispatchQueue.main.asyncAfter(deadline: .now() + 0.05) {
            self.startPlayback(in: size)
        }
    }
} */

// MARK: - Preview
struct ContentView_Previews: PreviewProvider {
    static var previews: some View {
        ContentView()
            .environmentObject(AppModel()) // or AppModel.shared
    }
}
