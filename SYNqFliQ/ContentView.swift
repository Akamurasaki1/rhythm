//
//  ContentView.swift
//  SYNqFliQ
//
//  Full, self-contained ContentView replacement.
//  This file recreates the primary gameplay view, bundled-sheet handling,
//  background/media loading, audio scheduling, history UI (carousel), and input handling.
//
//  Assumptions:
//  - Types Sheet, SheetNote, Note, and SheetFileManager exist elsewhere in your project (Models.swift).
//  - AppModel exists and provides selectedSheetFilename/selectedSheet and bundledSheets if you use it.
//  - This file intentionally keeps things in one place so you can replace your existing ContentView.swift.
//
//  Backup your existing file before replacing.
//
//  Generated by assistant to match the project's prior behavior.
//

import SwiftUI
import AVFoundation
import AVKit
import UniformTypeIdentifiers


// MARK: - ContentView

struct ContentView: View {
    @EnvironmentObject private var appModel: AppModel



    // MARK: State
    @State private var showingEditor: Bool = false
    @State private var bundledSheets: [(filename: String, sheet: Sheet)] = []
    @State private var sampleDataSets: [[Note]] = [] // empty builtin list
    private var sampleCount: Int { sampleDataSets.count + bundledSheets.count }

    // Background / media
    @State private var backgroundImage: UIImage? = nil
    @State private var backgroundPlayer: AVQueuePlayer? = nil
    @State private var backgroundPlayerLooper: AVPlayerLooper? = nil
    @State private var backgroundIsVideo: Bool = false
    @State private var backgroundFilename: String? = nil

    // Audio
    @State private var audioPlayer: AVAudioPlayer? = nil
    @State private var previewPlayer: AVAudioPlayer? = nil
    @State private var audioEngine: AVAudioEngine? = nil
    @State private var playerNode: AVAudioPlayerNode? = nil
    @State private var audioFile: AVAudioFile? = nil
    @State private var audioStartDeviceTime: TimeInterval? = nil
    @State private var audioSampleRate: Double = 44100.0
    @State private var currentlyPlayingAudioFilename: String? = nil
    // @State private var SFXPlayer = GlobalSFX.self

    // Playback / scheduling
    @State private var isPlaying: Bool = false
    @State private var isStopped: Bool = false // pause state
    @State private var startDate: Date? = nil
    @State private var notesToPlay: [Note] = []
    @State private var sheetNotesToPlay: [SheetNote] = []
    @State private var activeNotes: [ActiveNote] = []
    @State private var gameLoopTimer: DispatchSourceTimer? = nil
    private let gameLoopInterval: Double = 1.0 / 60.0
    @State private var initialScrollPerformed: Bool = false
    @State private var playheadTime: Double = 0.0
    // scheduling references for pause/resume
    @State private var scheduledSpawnTimes: [UUID: TimeInterval] = [:]
    @State private var scheduledClearTimes: [UUID: TimeInterval] = [:]
    @State private var scheduledSpawnWorkItemsByNote: [UUID: DispatchWorkItem] = [:]
    @State private var scheduledClearWorkItemsByNote: [UUID: DispatchWorkItem] = [:]
    @State private var scheduledNoteInfos: [UUID: (sheetNote: SheetNote, target: CGPoint, approachDuration: Double, spawnTime: Double, clearTime: Double)] = [:]
    @State private var scheduledWorkItems: [DispatchWorkItem] = []
    @State private var autoDeleteWorkItems: [UUID: DispatchWorkItem] = [:]
    @State private var pausedRemainingDelays: [UUID: (spawn: TimeInterval?, clear: TimeInterval?)] = [:]

    // hold timers
    @State private var holdTimers: [UUID: DispatchSourceTimer] = [:]

    // Input / gesture
    @State private var touchStartTime: Date? = nil
    @State private var touchStartLocation: CGPoint? = nil
    @State private var touchIsLongPress: Bool = false
    @State private var touchLongPressWorkItem: DispatchWorkItem? = nil
    @State private var isFingerDown: Bool = false
    @State private var fingerLocation: CGPoint? = nil
    @State private var touchToNote: [Int: UUID] = [:] // touch id -> activeNote id
    @State private var currentGestureID: UUID? = nil
    @State private var currentGestureHasFlicked: Bool = false

    // scoring
    @State private var score: Int = 0
    @State private var scorepoint: Int = 0
    @State private var HighScore: Int = 0
    @State private var combo: Int = 0
    @State private var maxCombo: Int = 0
    @State private var perfectCount: Int = 0
    @State private var goodCount: Int = 0
    @State private var okCount: Int = 0
    @State private var missCount: Int = 0
    @State private var cumulativeCombo: Int = 0
    @State private var consecutiveCombo: Int = 0
    @State private var playMaxHistory: [Int] = []

    @State private var showJudgementUntil: Date? = nil
    @State private var lastJudgement: String = ""
    @State private var lastJudgementColor: Color = .white

    // history UI
    @State private var playHistory: [PlayRecord] = []
    @State private var selectedRecord: PlayRecord? = nil
    @State private var isShowingRecordDetail: Bool = false

    // misc
    @State private var flickedNoteIDs: Set<UUID> = []
    @State private var preparedAudioPlayer: AVAudioPlayer? = nil
    @State private var testPlayer: AVAudioPlayer? = nil
    // tuning params
    private let perfectWindow: Double = 0.6
    private let goodWindowBefore: Double = 0.8
    private let goodWindowAfter: Double = 1.0
    private let lifeDuration: Double = 2.0
    private let speedThreshold: CGFloat = 35.0
    private let hitRadius: CGFloat = 110.0
    private let tapHitRadius: CGFloat = 10.0
    private let tapEarliestBeforeHit: Double = 0.3
    // @State private var approachDistanceFraction: Double = 0.25
    // @State private var approachSpeed: Double = 800.0
    // @State private var holdFillDurationFraction: Double = 1.0
    // @State private var holdFinishTrimThreshold: Double = 0.02
    // --- Insert into ContentView (inside the View struct) ---

    @EnvironmentObject private var settings: SettingsStore
    // Paste these inside ContentView (struct) near other helper functions.

    // Try to obtain a SE filename from a SheetNote using Mirror.
    // It will try several common property names: "seFilename","se","sound","hitSE","sample","sampleName","se_name"
 /*   private func seFilename(from sheetNote: Any) -> String? {
        let m = Mirror(reflecting: sheetNote)
        // first try strongly named properties
        let candidates = ["seFilename","se","sound","hitSE","sample","sampleName","se_name","sfx"]
        for c in candidates {
            if let v = m.children.first(where: { $0.label == c })?.value {
                if let s = v as? String, !s.isEmpty { return s }
                if let s = v as? OptionalProtocol {
                    // handled below
                }
            }
        }
        // fallback: search any String child that looks like a filename (contains '.' or common audio ext)
        for child in m.children {
            if let s = child.value as? String, s.contains(".") {
                let lower = s.lowercased()
                if lower.hasSuffix(".wav") || lower.hasSuffix(".mp3") || lower.hasSuffix(".m4a") || lower.hasSuffix(".caf") || lower.hasSuffix(".aiff") {
                    return s
                }
            }
        }
        return nil
    }

    // Helper protocol bridging for Mirror optional casting (not required for simple cases)
    private protocol OptionalProtocol {} */
    //extension Optional: OptionalProtocol {}
    // Explicit per-property Bindings to avoid keyPath subscript issues and make intent clear
    private var approachDistanceFractionBinding: Binding<Double> {
        Binding(get: { settings.approachDistanceFraction },
                set: { settings.approachDistanceFraction = $0 })
    }
    private var approachSpeedBinding: Binding<Double> {
        Binding(get: { settings.approachSpeed },
                set: { settings.approachSpeed = $0 })
    }
    private var holdFillDurationFractionBinding: Binding<Double> {
        Binding(get: { settings.holdFillDurationFraction },
                set: { settings.holdFillDurationFraction = $0 })
    }
    private var holdFinishTrimThresholdBinding: Binding<Double> {
        Binding(get: { settings.holdFinishTrimThreshold },
                set: { settings.holdFinishTrimThreshold = $0 })
    }
    // ContentView の中に追加
    private func playCountForSelectedSheet() -> Int {
        guard let selFilename = appModel.selectedSheetFilename else { return 0 }
        let all = PlayHistoryStorage.load()
        return all.filter { $0.sheetFilename == selFilename }.count
    }

    // Helpers for CGFloat conversions where needed
    private func cg(_ value: Double) -> CGFloat { CGFloat(value) }
    private func cgKeyPath(_ value: Double) -> CGFloat { CGFloat(value) } // convenience alias
    private let longPressThreshold: TimeInterval = 0.25
    // hold release judgement windows (add near other timing constants)
    private let holdReleaseGoodWindow: Double = 0.25
    private let holdReleaseOkWindow: Double = 1.0    // Carousel settings
    private let carouselItemWidth: CGFloat = 100
    private let carouselItemSpacing: CGFloat = 12
    private let repeatFactor = 1
    private func indicatorProgress(forNote a: ActiveNote, now: Double) -> Double {
        let hit = a.hitTime
        let approach = max(0.001, a.approachDuration)
        let start = hit - 2.0 * approach
        let end = hit

        if now <= start { return 0.0 }
        if now >= end { return 1.0 }

        let raw = (now - start) / (end - start) // 0..1
        let eased = pow(raw, 0.7)
        return min(max(eased, 0.0), 1.0)
    }
    // 1) resetAll — 既存の reset/stop 相当の安全な実装（必要なら内容をあなたの以前の実装に合わせて拡張）
    // Replace the existing resetAll() function in ContentView.swift with the implementation below.

    public func resetAll() {
        // Stop main game loop first
        stopGameLoopIfNeeded()

        // Stop/clear audio players
        if audioPlayer?.isPlaying == true { audioPlayer?.stop() }
        audioPlayer = nil

        if previewPlayer?.isPlaying == true { previewPlayer?.stop() }
        previewPlayer = nil

        if preparedAudioPlayer?.isPlaying == true { preparedAudioPlayer?.stop() }
        preparedAudioPlayer = nil

        if testPlayer?.isPlaying == true { testPlayer?.stop() }
        testPlayer = nil

        // Stop AVAudioEngine / nodes if used
        if let node = playerNode {
            node.stop()
        }
        playerNode = nil
        if let engine = audioEngine {
            engine.stop()
        }
        audioEngine = nil
        audioFile = nil
        audioStartDeviceTime = nil
        currentlyPlayingAudioFilename = nil

        // Try to deactivate audio session (best-effort)
        do {
            try AVAudioSession.sharedInstance().setActive(false, options: [])
        } catch {
            // ignore errors but log
            print("resetAll: AVAudioSession setActive(false) failed:", error)
        }

        // Stop background media
        if backgroundIsVideo {
            backgroundPlayer?.pause()
            backgroundPlayerLooper = nil
            backgroundPlayer = nil
        }
        backgroundImage = nil
        backgroundFilename = nil
        backgroundIsVideo = false

        // Stop any global SFX loops (hold loop etc.)
        // GlobalSFX interface used elsewhere; call stopHoldLoop at minimum.
        GlobalSFX.shared.stopHoldLoop()
        // If GlobalSFX has other stop/all methods, consider calling them here as well:
        // GlobalSFX.shared.stopAll() // <-- only call if implemented

        // Cancel and clear scheduled work items & timers
        scheduledWorkItems.forEach { $0.cancel() }
        scheduledWorkItems.removeAll()

        scheduledSpawnWorkItemsByNote.values.forEach { $0.cancel() }
        scheduledSpawnWorkItemsByNote.removeAll()

        scheduledClearWorkItemsByNote.values.forEach { $0.cancel() }
        scheduledClearWorkItemsByNote.removeAll()

        scheduledSpawnTimes.removeAll()
        scheduledClearTimes.removeAll()
        scheduledNoteInfos.removeAll()
        pausedRemainingDelays.removeAll()

        autoDeleteWorkItems.values.forEach { $0.cancel() }
        autoDeleteWorkItems.removeAll()

        holdTimers.values.forEach { $0.cancel() }
        holdTimers.removeAll()

        // Reset in-memory game state
        withAnimation(.easeOut(duration: 0.12)) {
            activeNotes.removeAll()
        }
        flickedNoteIDs.removeAll()

        // Reset scoring / UI
        scorepoint = 0
        score = 0
        combo = 0
        maxCombo = 0
        perfectCount = 0
        goodCount = 0
        okCount = 0
        missCount = 0
        cumulativeCombo = 0
        consecutiveCombo = 0
        playMaxHistory.removeAll()

        lastJudgement = ""
        showJudgementUntil = nil

        // Reset playback flags
        isPlaying = false
        isStopped = false
        startDate = nil

        // Clear any preview/share/import state
        isShowingResults = false
        isShowingShare = false
        shareURL = nil
        isShowingImportPicker = false
        importErrorMessage = nil

        // Ensure UI audio references cleared
        preparedAudioPlayer = nil
        previewPlayer = nil

        print("resetAll: cleared audio, background, timers, activeNotes and scoring")
    }
    // ContentView.swift の struct のプロパティ群の近くに追加
    @State private var showRecorderNotInstalledAlert = false
    // ContentView.swift の struct のメソッド領域（body の外）に追加
    private func openRecorderApp() {
        // ここを Recorder が登録しているスキームに合わせる（例: synqfliq-recorder）
        let scheme = "synqfliq-recorder"
        guard let url = URL(string: "\(scheme)://") else { return }

        if UIApplication.shared.canOpenURL(url) {
            UIApplication.shared.open(url, options: [:], completionHandler: nil)
        } else {
            // インストールされていない場合は App Store に誘導するかアラートを表示
            // ここでは簡易にアラートフラグを立てています。App Store に飛ばすなら下の comment を使ってください。
            showRecorderNotInstalledAlert = true

            // App Store に直接飛ばす例（App Store の実際の ID に置き換えてください）
            // if let appStoreURL = URL(string: "https://apps.apple.com/app/idYOUR_APPSTORE_ID") {
            //     UIApplication.shared.open(appStoreURL, options: [:], completionHandler: nil)
            // }
        }
    }
    private func handleImportedFile(url: URL) {
        DispatchQueue.global(qos: .userInitiated).async {
            var didStartAccess = false
            if url.startAccessingSecurityScopedResource() {
                didStartAccess = true
            }
            defer {
                if didStartAccess {
                    url.stopAccessingSecurityScopedResource()
                }
            }

            let fileManager = FileManager.default
            let destDir = SheetFileManager.documentsURL
            let destURL = destDir.appendingPathComponent(url.lastPathComponent)

            do {
                // Ensure destination directory exists
                try fileManager.createDirectory(at: destDir, withIntermediateDirectories: true, attributes: nil)

                // If file exists, append numeric suffix to avoid overwrite
                var finalDest = destURL
                var idx = 1
                while fileManager.fileExists(atPath: finalDest.path) {
                    let base = destURL.deletingPathExtension().lastPathComponent
                    let ext = destURL.pathExtension
                    let newName = "\(base)_\(idx).\(ext)"
                    finalDest = destDir.appendingPathComponent(newName)
                    idx += 1
                }

                // Copy the file
                try fileManager.copyItem(at: url, to: finalDest)
                print("Imported file copied to: \(finalDest.path)")

                DispatchQueue.main.async {
                    // reload bundledSheets / UI
                    bundledSheets = loadBundledSheets()
                    importErrorMessage = nil
                }
            } catch {
                DispatchQueue.main.async {
                    importErrorMessage = "Import failed: \(error.localizedDescription)"
                }
                print("Import copy failed:", error)
            }
        }
    }    // 2) long-press helper stubs (no-op safe defaults)
    private func handlePotentialLongPressStart(at location: CGPoint) {
        let t0 = Date()
        print("[LP] handlePotentialLongPressStart ENTER at \(location)")

        // 軽量な UI フラグだけ（メインスレッド）
        DispatchQueue.main.async {
            // 例: 長押しの視覚表示フラグ（ContentView 側で showLongPress を利用していれば）
            // self.showLongPress = true
        }

        // ログだけで終了（重い処理はここに入れない）
        let elapsed = Date().timeIntervalSince(t0)
        print("[LP] handlePotentialLongPressStart RETURN elapsed=\(elapsed)s")
    }

    private func handlePotentialLongPressEnd(at location: CGPoint, duration: TimeInterval) {
        let t0 = Date()
        print("[LP] handlePotentialLongPressEnd ENTER at \(location) dur=\(duration)")

        DispatchQueue.main.async {
            // self.showLongPress = false
        }

        let elapsed = Date().timeIntervalSince(t0)
        print("[LP] handlePotentialLongPressEnd RETURN elapsed=\(elapsed)s")
    }
    
    // 2) Add this helper inside ContentView (e.g., near other handlers) to bridge overlay -> existing handleFlick
/*private func handleFlickFromOverlay(noteId: UUID, start: CGPoint, end: CGPoint, duration: TimeInterval, canvasSize: CGSize) {
        // compute a pseudo DragGesture.Value for the existing handleFlick function
        // We only need predictedEndTranslation; approximate it as (end - start)
        // Build a small struct to mimic the pieces used in handleFlick
        struct SimpleDrag {
            var startLocation: CGPoint
            var location: CGPoint
            var predictedEndTranslation: CGSize
        }
        let predictedTranslation = CGSize(width: end.x - start.x, height: end.y - start.y)
        let simple = SimpleDrag(startLocation: start, location: end, predictedEndTranslation: predictedTranslation)
        // Find the active note index and call handleFlick(for:dragValue:in:)
        if let idx = activeNotes.firstIndex(where: { $0.id == noteId }) {
            // call existing handleFlick using the note id and synthesized data
            // Note: we can't pass SimpleDrag directly; create a small adapter via overloading handleFlick or inline logic:
            // We'll inline minimal flick behavior to reuse judgement and animation logic (same as handleFlick)
            if flickedNoteIDs.contains(noteId) { return }
            let flickVec = CGPoint(x: predictedTranslation.width, y: predictedTranslation.height)
            let flickSpeed = hypot(flickVec.x, flickVec.y) / CGFloat(max(1e-6, duration))
            guard flickSpeed > speedThreshold else { return }
            let note = activeNotes[idx]
            let theta = CGFloat(note.angleDegrees) * .pi / 180.0
            let rodDir = CGPoint(x: cos(theta), y: sin(theta))
            let n1 = CGPoint(x: -rodDir.y, y: rodDir.x); let n2 = CGPoint(x: rodDir.y, y: -rodDir.x)
            let dot1 = n1.x * flickVec.x + n1.y * flickVec.y
            let dot2 = n2.x * flickVec.x + n2.y * flickVec.y
            let chosenNormal = (dot1 >= dot2) ? n1 : n2
            let distance = max(canvasSize.width, canvasSize.height) * 1.5
            let target = CGPoint(x: note.position.x + chosenNormal.x * distance, y: note.position.y + chosenNormal.y * distance)
            if let work = autoDeleteWorkItems[noteId] { work.cancel(); autoDeleteWorkItems[noteId] = nil }
            flickedNoteIDs.insert(noteId)
            var elapsed: TimeInterval = 0.0
            if let player = audioPlayer, let startDev = audioStartDeviceTime { elapsed = player.deviceCurrentTime - startDev } else if let sd = startDate { elapsed = Date().timeIntervalSince(sd) }
            let dt = elapsed - note.hitTime
            var judgementText = "OK"; var judgementColor: Color = .white
            if abs(dt) <= perfectWindow { judgementText = "PERFECT"; judgementColor = .green; score += 3 }
            else if (dt >= -goodWindowBefore && dt < -perfectWindow) || (dt > perfectWindow && dt <= goodWindowAfter) { judgementText = "GOOD"; judgementColor = .blue; score += 2 }
            else { judgementText = "OK"; judgementColor = .white; score += 1 }
            combo += 1; if combo > maxCombo { maxCombo = combo }
            switch judgementText { case "PERFECT": perfectCount += 1; case "GOOD": goodCount += 1; case "OK": okCount += 1; default: break }
            showJudgement(text: judgementText, color: judgementColor)
            let flyDuration = 0.6
            withAnimation(.easeOut(duration: flyDuration)) {
                if let idx2 = activeNotes.firstIndex(where: { $0.id == noteId }) {
                    activeNotes[idx2].position = target
                }
            }
            DispatchQueue.main.asyncAfter(deadline: .now() + flyDuration + 0.05) {
                withAnimation(.easeIn(duration: 0.12)) { self.activeNotes.removeAll { $0.id == noteId } }
                self.flickedNoteIDs.remove(noteId)
            }
        } */
    // Replace your existing handleFlickFromOverlay implementation with this minimal-safe-update:
    // Key change: when computing the note's current origin/or position for the flying animation and judgement,
    // if note.position is .zero (not yet positioned/spawned), fall back to note.targetPosition.

    private func handleFlickFromOverlay(noteId: UUID, start: CGPoint, end: CGPoint, duration: TimeInterval, canvasSize: CGSize, reportedVelocity: CGFloat? = nil) {
        struct SimpleDrag {
            var startLocation: CGPoint
            var location: CGPoint
            var predictedEndTranslation: CGSize
        }
        let predictedTranslation = CGSize(width: end.x - start.x, height: end.y - start.y)
        let simple = SimpleDrag(startLocation: start, location: end, predictedEndTranslation: predictedTranslation)

        guard let idx = activeNotes.firstIndex(where: { $0.id == noteId }) else { return }
        if flickedNoteIDs.contains(noteId) { return }

        let note = activeNotes[idx]

        // Determine a sensible origin for the note: prefer current position; if it's zero (not yet set), use targetPosition.
        let origin = (note.position == .zero) ? note.targetPosition : note.position

        // flick vector / speed
        let flickVec = CGPoint(x: predictedTranslation.width, y: predictedTranslation.height)
        let dist = hypot(flickVec.x, flickVec.y)
        let computedSpeed = dist / CGFloat(max(1e-6, duration))
        let flickSpeed: CGFloat = {
            if let rep = reportedVelocity, rep > 0 { return max(computedSpeed, rep) }
            return computedSpeed
        }()

        print("DBG: handleFlickFromOverlay noteId=\(noteId) origin=\(origin) dist=\(dist) duration=\(duration) computedSpeed=\(computedSpeed) reported=\(String(describing: reportedVelocity)) flickSpeed=\(flickSpeed) threshold=\(speedThreshold)")

        guard flickSpeed > speedThreshold else {
            print("DBG: handleFlickFromOverlay skipped: flickSpeed \(flickSpeed) <= threshold \(speedThreshold)")
            return
        }

        let theta = CGFloat(note.angleDegrees) * .pi / 180.0
        let rodDir = CGPoint(x: cos(theta), y: sin(theta))
        let n1 = CGPoint(x: -rodDir.y, y: rodDir.x); let n2 = CGPoint(x: rodDir.y, y: -rodDir.x)
        let dot1 = n1.x * flickVec.x + n1.y * flickVec.y
        let dot2 = n2.x * flickVec.x + n2.y * flickVec.y
        let chosenNormal = (dot1 >= dot2) ? n1 : n2
        let distance = max(canvasSize.width, canvasSize.height) * 1.5
        let target = CGPoint(x: origin.x + chosenNormal.x * distance, y: origin.y + chosenNormal.y * distance)

        if let work = autoDeleteWorkItems[noteId] { work.cancel(); autoDeleteWorkItems[noteId] = nil }
        flickedNoteIDs.insert(noteId)

        var elapsed: TimeInterval = 0.0
        if let player = audioPlayer, let startDev = audioStartDeviceTime { elapsed = player.deviceCurrentTime - startDev } else if let sd = startDate { elapsed = Date().timeIntervalSince(sd) }
        let dt = elapsed - note.hitTime

        var judgementText = "OK"; var judgementColor: Color = .white
        if abs(dt) <= perfectWindow { judgementText = "PERFECT"; judgementColor = .green; score += 3 }
        else if (dt >= -goodWindowBefore && dt < -perfectWindow) || (dt > perfectWindow && dt <= goodWindowAfter) { judgementText = "GOOD"; judgementColor = .blue; score += 2 }
        else { judgementText = "OK"; judgementColor = .white; score += 1 }
        combo += 1; if combo > maxCombo { maxCombo = combo }
        switch judgementText { case "PERFECT": perfectCount += 1; case "GOOD": goodCount += 1; case "OK": okCount += 1; default: break }
        showJudgement(text: judgementText, color: judgementColor)
        GlobalSFX.shared.playFlickJudgement(judgementText)

        let flyDuration = 0.6
        withAnimation(.easeOut(duration: flyDuration)) {
            if let idx2 = activeNotes.firstIndex(where: { $0.id == noteId }) {
                activeNotes[idx2].position = target
            }
        }
        DispatchQueue.main.asyncAfter(deadline: .now() + flyDuration + 0.05) {
            withAnimation(.easeIn(duration: 0.12)) { self.activeNotes.removeAll { $0.id == noteId } }
            self.flickedNoteIDs.remove(noteId)
        }
    }
 /*   private func handleFlickFromOverlay(noteId: UUID, start: CGPoint, end: CGPoint, duration: TimeInterval, canvasSize: CGSize, reportedVelocity: CGFloat? = nil) {
        // compute a pseudo DragGesture.Value for the existing handleFlick function
        // We only need predictedEndTranslation; approximate it as (end - start)
        struct SimpleDrag {
            var startLocation: CGPoint
            var location: CGPoint
            var predictedEndTranslation: CGSize
        }
        let predictedTranslation = CGSize(width: end.x - start.x, height: end.y - start.y)
        let simple = SimpleDrag(startLocation: start, location: end, predictedEndTranslation: predictedTranslation)

        // Find the active note index and call handleFlick(using inline logic)
        guard let idx = activeNotes.firstIndex(where: { $0.id == noteId }) else { return }
        if flickedNoteIDs.contains(noteId) { return }

        // Compute flick vector and speed
        let flickVec = CGPoint(x: predictedTranslation.width, y: predictedTranslation.height)
        let dist = hypot(flickVec.x, flickVec.y)
        // computed speed from passed duration (seconds) — guard tiny durations
        let computedSpeed = dist / CGFloat(max(1e-6, duration))
        // If overlay provided a reported velocity (px/sec), use the max of both to be robust
        let flickSpeed: CGFloat
        if let rep = reportedVelocity, rep > 0 {
            flickSpeed = max(computedSpeed, rep)
        } else {
            flickSpeed = computedSpeed
        }

        print("DBG: handleFlickFromOverlay noteId=\(noteId) dist=\(dist) duration=\(duration) computedSpeed=\(computedSpeed) reported=\(String(describing: reportedVelocity)) flickSpeed=\(flickSpeed) threshold=\(speedThreshold)")

        guard flickSpeed > speedThreshold else {
            print("DBG: handleFlickFromOverlay skipped: flickSpeed \(flickSpeed) <= threshold \(speedThreshold)")
            return
        }

        let note = activeNotes[idx]
        let theta = CGFloat(note.angleDegrees) * .pi / 180.0
        let rodDir = CGPoint(x: cos(theta), y: sin(theta))
        let n1 = CGPoint(x: -rodDir.y, y: rodDir.x); let n2 = CGPoint(x: rodDir.y, y: -rodDir.x)
        let dot1 = n1.x * flickVec.x + n1.y * flickVec.y
        let dot2 = n2.x * flickVec.x + n2.y * flickVec.y
        let chosenNormal = (dot1 >= dot2) ? n1 : n2
        let distance = max(canvasSize.width, canvasSize.height) * 1.5
        let target = CGPoint(x: note.position.x + chosenNormal.x * distance, y: note.position.y + chosenNormal.y * distance)

        if let work = autoDeleteWorkItems[noteId] { work.cancel(); autoDeleteWorkItems[noteId] = nil }
        flickedNoteIDs.insert(noteId)

        var elapsed: TimeInterval = 0.0
        if let player = audioPlayer, let startDev = audioStartDeviceTime { elapsed = player.deviceCurrentTime - startDev }
        else if let sd = startDate { elapsed = Date().timeIntervalSince(sd) }
        let dt = elapsed - note.hitTime

        var judgementText = "OK"; var judgementColor: Color = .white
        if abs(dt) <= perfectWindow { judgementText = "PERFECT"; judgementColor = .green; score += 3 }
        else if (dt >= -goodWindowBefore && dt < -perfectWindow) || (dt > perfectWindow && dt <= goodWindowAfter) { judgementText = "GOOD"; judgementColor = .blue; score += 2 }
        else { judgementText = "OK"; judgementColor = .white; score += 1 }
        combo += 1; if combo > maxCombo { maxCombo = combo }
        switch judgementText { case "PERFECT": perfectCount += 1; case "GOOD": goodCount += 1; case "OK": okCount += 1; default: break }
        showJudgement(text: judgementText, color: judgementColor)
        GlobalSFX.shared.playFlickJudgement(judgementText)

        let flyDuration = 0.6
        withAnimation(.easeOut(duration: flyDuration)) {
            if let idx2 = activeNotes.firstIndex(where: { $0.id == noteId }) {
                activeNotes[idx2].position = target
            }
        }
        DispatchQueue.main.asyncAfter(deadline: .now() + flyDuration + 0.05) {
            withAnimation(.easeIn(duration: 0.12)) { self.activeNotes.removeAll { $0.id == noteId } }
            self.flickedNoteIDs.remove(noteId)
        }

    } */
    // MARK: - Body
    // 追加: ContentView struct の内部（body の外）に置いてください
    @ViewBuilder
    private func activeNotesStack(geo: GeometryProxy) -> some View {
        ForEach(activeNotes, id: \.id) { a in
            // indicator を先に描画（AnyView で型を固定）
            AnyView(flickIndicatorView(for: a, now: playheadTime))
            
            // 1ノート分の描画は ActiveNoteView に一本化する
            ActiveNoteView(
                note: a,
                playheadTime: playheadTime,
                canvasSize: geo.size,
            /*    onFlick: { dragValue in
                    // ブリッジ：ActiveNoteView からのフリックを既存のハンドラへ
                    handleFlick(for: a.id, dragValue: dragValue, in: geo.size)
                }*/
            )
        }
    }
    // temporarily replace var body: some View { ... } with this minimal body
    var body: some View {
     /*   VStack(spacing: 8) {
            Text("This is ContentView")
                .font(.system(size: 48, weight: .heavy, design: .rounded))
                .foregroundColor(.white)
                .shadow(color: .black.opacity(0.6), radius: 8, x: 0, y: 4)
        } */
        GeometryReader { geo in
            ZStack {
                /*   TouchOverlay(
                 onTap: { id, loc in
                 guard isPlaying && !isStopped else { return }
                 handleTap(at: loc, in: loc)
                 },
                 onMove: { id, loc in
                 self.fingerLocation = loc
                 },
                 onHoldStart: { id, loc in
                 guard isPlaying && !isStopped else { return }
                 // optional: assign touch->note mapping
                 if let nid = findNearestNoteId(to: loc) { touchToNote[id] = nid }
                 self.fingerLocation = loc
                 self.isFingerDown = true
                 handleHoldTouchBegan(at: loc)
                 },
                 onHoldEnd: { id, loc, duration in
                 guard isPlaying && !isStopped else { return }
                 if let assigned = touchToNote[id] {
                 // use assigned mapping if available
                 handleHoldTouchEnded(at: loc)
                 touchToNote[id] = nil
                 } else {
                 handleHoldTouchEnded(at: loc)
                 }
                 self.isFingerDown = false
                 self.fingerLocation = nil
                 },
                 onFlick: { id, start, end, velocity in
                 guard isPlaying && !isStopped else { return }
                 // nearest-note lookup (same as before)
                 var closestId: UUID? = nil; var closestDist = CGFloat.greatestFiniteMagnitude
                 for n in activeNotes {
                 let d = hypot(n.position.x - start.x, n.position.y - start.y)
                 if d < closestDist { closestDist = d; closestId = n.id }
                 }
                 if let noteId = closestId, closestDist <= hitRadius {
                 // compute duration as time = distance / speed (speed is px/sec from TouchOverlay)
                 let dx = end.x - start.x
                 let dy = end.y - start.y
                 let dist = hypot(dx, dy)
                 let vel = max(CGFloat(1.0), velocity) // avoid division by zero; velocity is px/sec
                 let dur = TimeInterval(dist / vel)    // seconds
                 // ensure a tiny positive duration
                 let safeDur = max(0.001, dur)
                 handleFlickFromOverlay(noteId: noteId, start: start, end: end, duration: safeDur, canvasSize: geo.size)
                 }
                 }
                 )
                 .frame(maxWidth: .infinity, maxHeight: .infinity)
                 .allowsHitTesting(isPlaying && !isStopped)
                 .ignoresSafeArea()
                 .zIndex(99) */
                // debug: show game coordinate bounds
                Color.clear
                    .frame(width: geo.size.width, height: geo.size.height)
                    .border(Color.red, width: 10) // ← これでゲーム座標の領域が赤枠で出ます
                    .allowsHitTesting(false)
                // Background
                if let ui = backgroundImage {
                    Image(uiImage: ui)
                        .resizable()
                        .scaledToFill()
                        .frame(width: geo.size.width, height: geo.size.height)
                        .clipped()
                        .ignoresSafeArea()
                } else if backgroundIsVideo, let player = backgroundPlayer {
                    VideoPlayer(player: player)
                        .frame(width: geo.size.width, height: geo.size.height)
                        .clipped()
                        .ignoresSafeArea()
                } else {
                    Color.black.ignoresSafeArea()
                }
                
                // Interaction overlay: handles touches for hold notes
                // replace the existing TouchOverlay(...) block with this
                // Place this inside ContentView's ZStack near the top (replace existing "選曲に戻る" button)
                // (excerpt) Replace the existing "選曲に戻る" button block with this code.
                // Put this inside ContentView's ZStack near the top (replacing previous button).
                VStack {
                    HStack {
                        Button(action: {
                            print("DBG: Back-to-selection button tapped. before selected = \(String(describing: appModel.selectedSheetFilename)), showingSongSelection = \(appModel.showingSongSelection)")
                            
                            // Close local modals so they don't block navigation
                            isShowingRecordDetail = false
                            isShowingResults = false
                            isShowingShare = false
                            showingEditor = false
                            isShowingImportPicker = false
                            
                            // Do NOT clear appModel.selectedSheetFilename here (don't overwrite user's selection).
                            // Just request the song-selection UI.
                            appModel.openSongSelection()
                            
                            print("DBG: Back-to-selection action dispatched. after selected = \(String(describing: appModel.selectedSheetFilename)), showingSongSelection = \(appModel.showingSongSelection)")
                        })  {
                            HStack(spacing: 8) {
                                Image(systemName: "arrow.uturn.left")
                                    .font(.system(size: 14, weight: .semibold))
                                Text("選曲に戻る")
                                    .font(.subheadline)
                            }
                            .padding(8)
                            .background(Color.black.opacity(0.45))
                            .foregroundColor(.white)
                            .cornerRadius(8)
                        }
                        Spacer()
                    }
                    .padding(.top, 12)
                    .padding(.horizontal, 12)
                    Spacer()
                }
                .allowsHitTesting(true)
                .zIndex(1000)
                // Main UI VStack
                VStack {
                    // Header: score / combo
                    HStack {
                        
                        VStack(alignment: .leading) {
                            Text("Score: \(score)").foregroundColor(.white).font(.headline)
                            Text("Combo: \(combo)").foregroundColor(.yellow).font(.subheadline)
                        }
                        Spacer()
                        if shouldShowJudgement() {
                            Text(lastJudgement)
                                .font(.title2)
                                .bold()
                                .foregroundColor(lastJudgementColor)
                                .padding(8)
                                .background(Color.black.opacity(0.6))
                                .cornerRadius(8)
                        }
                    }
                    .padding(.horizontal)
                    .padding(.top, 8)
                    
                    
                    // Tuning UI (hidden while playing)
                    if !isPlaying {
                        VStack(spacing: 8) {
                            HStack {
                                Text("Approach dist (fraction): \(String(format: "%.2f", settings.approachDistanceFraction))")
                                    .foregroundColor(.white)
                                Spacer()
                            }
                            Slider(value: approachDistanceFractionBinding, in: 0.05...1.5)
                            HStack {
                                Text("Approach speed (pts/s): \(Int(settings.approachSpeed))")
                                    .foregroundColor(.white)
                                Spacer()
                                let exampleDistance = settings.approachDistanceFraction * min(geo.size.width, geo.size.height)
                                let derivedDuration = exampleDistance / max(settings.approachSpeed, 1.0)
                                Text("例 dur: \(String(format: "%.2f", derivedDuration))s")
                                    .foregroundColor(.gray)
                            }
                            Slider(value: $settings.approachSpeed, in: 100...3000)
                            VStack {
                                HStack {
                                    Text("Hold fill fraction: \(String(format: "%.2f", settings.holdFillDurationFraction))")
                                        .foregroundColor(.white)
                                    Spacer()
                                }
                                Slider(value: $settings.holdFillDurationFraction, in: 0.2...1.8)
                                HStack {
                                    Text("Hold finish trim threshold: \(String(format: "%.3f", settings.holdFinishTrimThreshold))")
                                        .foregroundColor(.white)
                                    Spacer()
                                }
                                Slider(value: $settings.holdFinishTrimThreshold, in: 0.001...0.08)
                            }
                        }
                        .padding(.horizontal)
                        .padding(.top, 6)
                    }
                    
                    Spacer()
                } // VStack
                
                // Active notes rendering
                // Active notes rendering (差し替え用)
                // 置き換え前:
                // ForEach(activeNotes) { a in ... }
                TouchOverlay(
                    onTap: { id, loc in
                        print("DBG TouchOverlay.onTap id=\(id) loc=\(loc)")
                        guard isPlaying && !isStopped else { return }
                        handleTap(at: loc, in: loc)
                    },
                    onMove: { id, loc in
                        // Minimal debug
                        // print("DBG TouchOverlay.onMove id=\(id) loc=\(loc)")
                        self.fingerLocation = loc
                    },
                    onHoldStart: { id, loc in
                        print("DBG TouchOverlay.onHoldStart id=\(id) loc=\(loc)")
                        guard isPlaying && !isStopped else { return }
                        if let nid = findNearestNoteId(to: loc) { touchToNote[id] = nid }
                        self.fingerLocation = loc
                        self.isFingerDown = true
                        handleHoldTouchBegan(at: loc)
                    },
                    onHoldEnd: { id, loc, duration in
                        print("DBG TouchOverlay.onHoldEnd id=\(id) loc=\(loc) dur=\(duration)")
                        guard isPlaying && !isStopped else { return }
                        if let assigned = touchToNote[id] {
                            handleHoldTouchEnded(at: loc)
                            touchToNote[id] = nil
                        } else {
                            handleHoldTouchEnded(at: loc)
                        }
                        self.isFingerDown = false
                        self.fingerLocation = nil
                    }, // In your TouchOverlay onFlick closure, pass the reported velocity into handleFlickFromOverlay.
                    // Replace the onFlick body with the following (keep surrounding TouchOverlay(...) unchanged).

                    // Replace just the onFlick: { ... } closure body in your TouchOverlay(...) block with this version.
                    // Key change: use note.targetPosition (fallback to position) for distance/segment tests instead of n.position.
               /*     onFlick: { id, start, end, velocity in
                        print("DBG TouchOverlay.onFlick raw id=\(id) start=\(start) end=\(end) reportedSpeed=\(velocity)")
                        guard isPlaying && !isStopped else { return }

                        // Helper: distance from point p to segment vw
                        func pointToSegmentDistance(_ p: CGPoint, _ v: CGPoint, _ w: CGPoint) -> CGFloat {
                            let l2 = pow(w.x - v.x, 2) + pow(w.y - v.y, 2)
                            if l2 == 0 { return hypot(p.x - v.x, p.y - v.y) } // v == w
                            var t = ((p.x - v.x) * (w.x - v.x) + (p.y - v.y) * (w.y - v.y)) / l2
                            t = max(0.0, min(1.0, t))
                            let proj = CGPoint(x: v.x + t * (w.x - v.x), y: v.y + t * (w.y - v.y))
                            return hypot(p.x - proj.x, p.y - proj.y)
                        }

                        // current playhead time (same concept as game loop uses)
                        let nowPlayhead: Double = self.playheadTime

                        var bestId: UUID? = nil
                        var bestDist: CGFloat = .greatestFiniteMagnitude
                        var bestMetric: String = "start"
                        var bestTimeDiff: Double = Double.greatestFiniteMagnitude

                        for n in activeNotes {
                            // prefer a stable reference point: use targetPosition if available, else position
                            let ref = (n.targetPosition != .zero) ? n.targetPosition : n.position

                            // distances from start, end and segment
                            let dStart = hypot(ref.x - start.x, ref.y - start.y)
                            let dEnd   = hypot(ref.x - end.x,   ref.y - end.y)
                            let dSeg   = pointToSegmentDistance(ref, start, end)
                            let dMin   = min(dStart, dEnd, dSeg)

                            // temporal proximity (how close the note's hit time is to now)
                            let timeDiff = abs(n.hitTime - nowPlayhead) // seconds

                            // Choose best candidate using a composite score: spatial distance plus a small time penalty.
                            // This prefers notes that are both spatially close and near in time.
                            // weightTime: how many extra 'px' per second of time difference (tunable)
                            let weightTime: CGFloat = 80.0
                            let compositeScore = dMin + CGFloat(min(timeDiff, 2.0)) * weightTime

                            if compositeScore < (bestDist + CGFloat(min(bestTimeDiff, 2.0)) * weightTime) {
                                bestId = n.id
                                bestDist = dMin
                                bestMetric = (dMin == dStart) ? "start" : (dMin == dEnd ? "end" : "segment")
                                bestTimeDiff = timeDiff
                            }
                        }

                        print("DBG onFlick nearestId=\(String(describing: bestId)) dist=\(bestDist) via=\(bestMetric) hitRadius=\(hitRadius) timeDiff=\(bestTimeDiff) playhead=\(nowPlayhead) activeCount=\(activeNotes.count) canvas=\(geo.size)")

                        // Compute an effective spatial threshold that grows modestly when the note is close in time.
                        // If the note is near the playhead (timeDiff small), allow a larger spatial tolerance.
                        func effectiveRadius(for timeDiff: Double) -> CGFloat {
                            // if within closeTimeWindow seconds, grow tolerance linearly up to maxMultiplier
                            let closeTimeWindow: Double = 1.2 // seconds
                            let maxMultiplier: CGFloat = 2.5   // up to 2.5x the hitRadius
                            if timeDiff >= closeTimeWindow { return hitRadius }
                            let t = CGFloat((closeTimeWindow - timeDiff) / closeTimeWindow) // 0..1 when within window
                            return hitRadius * (1.0 + t * (maxMultiplier - 1.0))
                        }

                        if let noteId = bestId {
                            // find the chosen note and compute distances for debugging output
                            if let note = activeNotes.first(where: { $0.id == noteId }) {
                                let ref = (note.targetPosition != .zero) ? note.targetPosition : note.position
                                let dStart = hypot(ref.x - start.x, ref.y - start.y)
                                let dEnd   = hypot(ref.x - end.x,   ref.y - end.y)
                                let dSeg   = pointToSegmentDistance(ref, start, end)
                                print("DBG onFlick candidate note id=\(noteId) ref=\(ref) position=\(note.position) target=\(note.targetPosition) dStart=\(dStart) dEnd=\(dEnd) dSeg=\(dSeg)")
                                let eff = effectiveRadius(for: bestTimeDiff)
                                print("DBG onFlick effectiveRadius=\(eff) (base hitRadius=\(hitRadius))")
                                if bestDist <= eff {
                                    // compute duration and delegate
                                    let dx = end.x - start.x
                                    let dy = end.y - start.y
                                    let dist = hypot(dx, dy)
                                    let vel = max(CGFloat(1.0), velocity)
                                    let dur = TimeInterval(dist / vel)
                                    let safeDur = max(0.001, dur)
                                    print("DBG onFlick computed dist=\(dist) vel=\(vel) dur=\(dur) safeDur=\(safeDur) -> calling handler")
                                    handleFlickFromOverlay(noteId: noteId, start: start, end: end, duration: safeDur, canvasSize: geo.size)
                                    return
                                } else {
                                    print("DBG onFlick ignored (bestDist \(bestDist) > effectiveRadius \(eff))")
                                }
                            }
                        } else {
                            print("DBG onFlick ignored (no candidate found)")
                        }
                    }
                 */  onFlick: { id, start, end, velocity in
                        print("DBG TouchOverlay.onFlick raw id=\(id) start=\(start) end=\(end) reportedSpeed=\(velocity)")
                        guard isPlaying && !isStopped else { return }

                        // Helper: distance from point p to segment vw
                        func pointToSegmentDistance(_ p: CGPoint, _ v: CGPoint, _ w: CGPoint) -> CGFloat {
                            let l2 = pow(w.x - v.x, 2) + pow(w.y - v.y, 2)
                            if l2 == 0 { return hypot(p.x - v.x, p.y - v.y) } // v == w
                            var t = ((p.x - v.x) * (w.x - v.x) + (p.y - v.y) * (w.y - v.y)) / l2
                            t = max(0.0, min(1.0, t))
                            let proj = CGPoint(x: v.x + t * (w.x - v.x), y: v.y + t * (w.y - v.y))
                            return hypot(p.x - proj.x, p.y - proj.y)
                        }

                        var closestId: UUID? = nil
                        var closestDist = CGFloat.greatestFiniteMagnitude
                        var chosenMetric = "start"

                        for n in activeNotes {
                            // IMPORTANT: prefer n.targetPosition (where the note is headed). If unavailable, fall back to n.position.
                            let ref = (n.targetPosition != .zero) ? n.targetPosition : n.position
                            // distances: from start, end, and perpendicular to segment (all relative to ref)
                            let dStart = hypot(ref.x - start.x, ref.y - start.y)
                            let dEnd   = hypot(ref.x - end.x,   ref.y - end.y)
                            let dSeg   = pointToSegmentDistance(ref, start, end)
                            let d = min(dStart, dEnd, dSeg)
                            if d < closestDist {
                                closestDist = d
                                closestId = n.id
                                if d == dStart { chosenMetric = "start" }
                                else if d == dEnd { chosenMetric = "end" }
                                else { chosenMetric = "segment" }
                            }
                        }

                        print("DBG onFlick nearestId=\(String(describing: closestId)) dist=\(closestDist) via=\(chosenMetric) hitRadius=\(hitRadius) activeCount=\(activeNotes.count) canvas=\(geo.size)")

                        if let noteId = closestId {
                            if let note = activeNotes.first(where: { $0.id == noteId }) {
                                let ref = (note.targetPosition != .zero) ? note.targetPosition : note.position
                                let dStart = hypot(ref.x - start.x, ref.y - start.y)
                                let dEnd   = hypot(ref.x - end.x,   ref.y - end.y)
                                let dSeg   = pointToSegmentDistance(ref, start, end)
                                print("DBG onFlick candidate note id=\(noteId) ref=\(ref) position=\(note.position) target=\(note.targetPosition) dStart=\(dStart) dEnd=\(dEnd) dSeg=\(dSeg)")
                            }
                        }

                        if let noteId = closestId, closestDist <= hitRadius {
                            // compute duration from distance/velocity (velocity is px/sec)
                            let dx = end.x - start.x
                            let dy = end.y - start.y
                            let dist = hypot(dx, dy)
                            let vel = max(CGFloat(1.0), velocity)
                            let dur = TimeInterval(dist / vel)
                            let safeDur = max(0.001, dur)
                            print("DBG onFlick computed dist=\(dist) vel=\(vel) dur=\(dur) safeDur=\(safeDur)")
                            handleFlickFromOverlay(noteId: noteId, start: start, end: end, duration: safeDur, canvasSize: geo.size)
                        } else {
                            print("DBG onFlick ignored (no nearby note on path)")
                        }
                    }
                    
                )
                .frame(maxWidth: .infinity, maxHeight: .infinity)
                .allowsHitTesting(isPlaying && !isStopped) // keep hit testing only while playing
                .ignoresSafeArea()
                .zIndex(55) // above notes but below header (header uses zIndex 1000)
                // 置き換え後:
                activeNotesStack(geo: geo)
                // Bottom controls
                VStack {
                    Spacer()
                    HStack {
                        Spacer()
                        Button(action: {
                            if isPlaying && !isStopped {
                                pausePlayback()
                            } else if isPlaying && isStopped {
                                resumePlayback()
                                if let player = audioPlayer { player.play() }
                            } else {
                                // Start new play using appModel.selectedSheet (SongSelectionView manages selection)
                                if let sel = appModel.selectedSheet {
                                    sheetNotesToPlay = sel.notes
                                    notesToPlay = sel.notes.asNotes()
                                } else {
                                    sheetNotesToPlay = []
                                    notesToPlay = []
                                }
                                startPlayback(in: geo.size)
                            }
                        }) {
                          //  if (isPlaying && !isStopped || isPlaying && isStopped) {
                                Text(isPlaying && !isStopped ? "Stop" : (isPlaying && isStopped ? "Resume" : "Start"))
                                    .font(.headline)
                                    .padding(.vertical, 10)
                                    .padding(.horizontal, 16)
                                    .background((isPlaying && !isStopped) ? Color.red : Color.green)
                                    .foregroundColor(.white)
                                    .cornerRadius(8)
                                  //  .position(.bottom, alignment: .center)
                          //  }else{
                            //    Text("Start")
                          //          .font(.title)
                              //      .fontWeight(.bold)
                                //    .position(.center, alignment: .center)
                           // }
                        }
                    
                        Spacer()
                        Button(action: {
                            openRecorderApp()
                        }) {
                            Text("Editor")
                                .font(.subheadline)
                                .padding(8)
                                .background(Color.blue.opacity(0.85))
                                .foregroundColor(.white)
                                .cornerRadius(6)
                        }
                        .alert(isPresented: $showRecorderNotInstalledAlert) {
                            Alert(
                                title: Text("Recorder アプリが見つかりません"),
                                message: Text("SYNqFliQRecorder が端末にインストールされていません。App Store で開きますか？"),
                                primaryButton: .default(Text("App Storeへ"), action: {
                                    if let appStoreURL = URL(string: "https://apps.apple.com/app/idYOUR_APPSTORE_ID") {
                                        UIApplication.shared.open(appStoreURL, options: [:], completionHandler: nil)
                                    }
                                }),
                                secondaryButton: .cancel()
                            )
                        }
                        Spacer()
                        Button(action: {
                            isShowingImportPicker = true
                        }) {
                            Text("Import")
                                .font(.subheadline)
                                .padding(8)
                                .background(Color.orange.opacity(0.9))
                                .foregroundColor(.white)
                                .cornerRadius(6)
                        }
                        Button(action: {
                            resetAll()
                        }) {
                            Text("Reset")
                                .font(.subheadline)
                                .padding(8)
                                .background(Color.gray.opacity(0.3))
                                .cornerRadius(6)
                        }
                        Spacer()
                    }
                    .padding(.bottom, 12)
                  
                  /*  .sheet(isPresented: $isShowingRecordDetail) {
                        if let rec = selectedRecord {
                            PlayRecordDetailView(record: rec, onPreview: { record in
                                if let fn = record.sheetFilename,
                                   let idx = bundledSheets.firstIndex(where: { $0.filename == fn }) {
                                    // load and preview
                                    previewAndPlaySheet(at: idx)
                                    isShowingRecordDetail = false
                                } else {
                                    print("DBG: Preview: sheet not found for record \(record.sheetFilename ?? "nil")")
                                }
                            })
                        } else {
                            // show list when opened without selecting from thumbnail
                            HistoryListView(records: playHistory, onSelect: { rec in
                                selectedRecord = rec
                                isShowingRecordDetail = true
                            })
                        }
                    }*/
                    // 新: ContentView のどこか（下部ボタン群の modifier chain）
                    // compute playCount for the currently selected sheet

                    .sheet(isPresented: $isShowingResults) {
                        ResultsView(
                            score: score,
                            maxCombo: maxCombo,
                            perfect: perfectCount,
                            good: goodCount,
                            ok: okCount,
                            miss: missCount,
                            cumulativeCombo: cumulativeCombo,
                            playMaxHistory: playMaxHistory,
                            consecutiveCombo: consecutiveCombo,
                            playCount: playCountForSelectedSheet(),
                            onPlayAgain: {
                                if !isPlaying {
                                    if let sel = appModel.selectedSheet {
                                        sheetNotesToPlay = sel.notes
                                        notesToPlay = sel.notes.asNotes()
                                        DispatchQueue.main.asyncAfter(deadline: .now() + 0.15) {
                                            startPlayback(in: UIScreen.main.bounds.size)
                                        }
                                    }
                                }
                            },
                            onBackToSelection: {
                                appModel.openSongSelection()
                            },
                            onSave: {
                             //   appendPlayHistoryRecord() これ入れるとsaveボタン押すたびにプレイ回数が増えてしまう
                            },
                            onShare: { items in
                                // present UIActivityViewController from root
                                guard let wnd = UIApplication.shared.connectedScenes.compactMap({ $0 as? UIWindowScene }).first?.windows.first,
                                      let root = wnd.rootViewController else { return }
                                let ac = UIActivityViewController(activityItems: items, applicationActivities: nil)
                                root.present(ac, animated: true)
                            }
                        )
                    }
                .sheet(isPresented: $isShowingShare) {
                        if let url = shareURL {
                            ShareSheet(activityItems: [url])
                        } else {
                            Text("No file to share.")
                        }
                    }

                    if !isPlaying {
                        HStack {
                            Text("Selected: \(appModel.selectedSheet?.title ?? "—")")
                                .foregroundColor(.white)
                            Spacer()
                            Text("Difficulty: \(appModel.selectedSheet?.difficulty ?? "-"):\(appModel.selectedSheet?.level.map { String($0) } ?? "-")")
                                .foregroundColor(.white)
                        }
                        .padding(.bottom, 20)
                    } else {
                        HStack {
                            Text("  \(appModel.selectedSheet?.title ?? "—")")
                                .foregroundColor(.white)
                            Spacer()
                            Text("\(appModel.selectedSheet?.difficulty ?? "-"):\(appModel.selectedSheet?.level.map { String($0) } ?? "-")")
                                .foregroundColor(.white)
                        }
                        .padding(.bottom, 20)
                    }
                }.zIndex(1000)
            } // ZStack
            .contentShape(Rectangle())
            // Replace the existing .simultaneousGesture(...) and .gesture(...) modifiers on the ZStack (near the end of GeometryReader)
            // with this version: the DragGesture(s) are attached only when isPlaying && !isStopped && isFingerDown is true.
            // This prevents SwiftUI from capturing single-finger drags (so TouchOverlay receives them).
            // Replace the existing .simultaneousGesture(...) and .gesture(...) modifiers on the ZStack (near the end of GeometryReader)
            // with this version. Key changes:
            // - DragGesture only updates fingerLocation in onChanged (no handleTap/handleHold calls).
            // - onEnded only calls handleGlobalFlick when the drag distance exceeds a threshold.
            // - minimumDistance is > 0 so short taps won't be recognized by the DragGesture and will be delivered to TouchOverlay.

            .simultaneousGesture(
                (isPlaying && !isStopped && isFingerDown) ? DragGesture(minimumDistance: 8) // small threshold to avoid capturing taps
                    .onChanged { value in
                        // Do minimal work: update finger location only.
                        // Keep this lightweight so it doesn't interfere with TouchOverlay handling of hold/tap.
                        fingerLocation = value.location
                    }
                    .onEnded { value in
                        // Only treat as a flick if the user performed a meaningful drag.
                        let dx = value.location.x - value.startLocation.x
                        let dy = value.location.y - value.startLocation.y
                        let dist = hypot(dx, dy)

                        // Tune this distance threshold if needed (20..40px is reasonable)
                        let flickDistanceThreshold: CGFloat = 24.0

                        if dist >= flickDistanceThreshold {
                            // call existing global flick handler
                            handleGlobalFlick(dragValue: value, in: geo.size)
                        } else {
                            // short movement: let TouchOverlay handle taps/holds; do nothing here
                            // (no handleTap / handleHoldTouchEnded calls)
                        }

                        // Ensure we don't accidentally leave per-gesture state
                        currentGestureID = nil
                        currentGestureHasFlicked = false
                        touchStartTime = nil
                        touchStartLocation = nil
                        touchIsLongPress = false
                    } : nil
            )
            .gesture(
                (isPlaying && !isStopped && isFingerDown) ?
                    DragGesture(minimumDistance: 16)
                        .onEnded { value in
                            // Dedicated flick gesture: only invoked onEnded to call handleGlobalFlick.
                            let dx = value.location.x - value.startLocation.x
                            let dy = value.location.y - value.startLocation.y
                            let dist = hypot(dx, dy)
                            let flickDistanceThreshold: CGFloat = 24.0
                            if dist >= flickDistanceThreshold {
                                handleGlobalFlick(dragValue: value, in: geo.size)
                            }
                        } : nil
            )
            // Global drag gesture used for flicks / taps — attached only when a hold (isFingerDown) exists.
      /*      .simultaneousGesture(
                (isPlaying && !isStopped && isFingerDown) ? DragGesture(minimumDistance: 0)
                    .onChanged { value in
                        if touchStartTime == nil {
                            touchStartTime = Date()
                            touchStartLocation = value.startLocation
                            touchIsLongPress = false
                            currentGestureID = UUID()
                            currentGestureHasFlicked = false
                            let work = DispatchWorkItem {
                                DispatchQueue.main.async {
                                    touchIsLongPress = true
                                    handlePotentialLongPressStart(at: value.startLocation)
                                }
                            }
                            touchLongPressWorkItem?.cancel()
                            touchLongPressWorkItem = work
                            DispatchQueue.global().asyncAfter(deadline: .now() + longPressThreshold, execute: work)
                            handleHoldTouchBegan(at: value.startLocation)
                        } else {
                            fingerLocation = value.location
                        }
                    }
                    .onEnded { value in
                        touchLongPressWorkItem?.cancel()
                        touchLongPressWorkItem = nil
                        let start = touchStartTime ?? Date()
                        let duration = Date().timeIntervalSince(start)
                        let dx = value.location.x - (touchStartLocation?.x ?? value.location.x)
                        let dy = value.location.y - (touchStartLocation?.y ?? value.location.y)
                        let dist = hypot(dx, dy)

                        if touchIsLongPress {
                            handlePotentialLongPressEnd(at: value.location, duration: duration)
                        } else {
                            if dist < 20.0 {
                                handleTap(at: value.location, in: value.startLocation)
                            } else {
                                handleGlobalFlick(dragValue: value, in: geo.size)
                            }
                        }

                        handleHoldTouchEnded(at: value.location)

                        // reset gesture
                        currentGestureID = nil
                        currentGestureHasFlicked = false
                        touchStartTime = nil
                        touchStartLocation = nil
                        touchIsLongPress = false
                    } : nil
            )
            .gesture(
                (isPlaying && !isStopped && isFingerDown) ?
                    DragGesture(minimumDistance: 16)
                        .onEnded { value in
                            handleGlobalFlick(dragValue: value, in: geo.size)
                        } : nil
            ) //<-FLICKはもどるけどTap+holdができなくなるやつ */
            // Global drag gesture used for flicks / taps
       /*    .simultaneousGesture(
                (isPlaying && !isStopped) ? DragGesture(minimumDistance: 0)
                    .onChanged { value in
                        if touchStartTime == nil {
                            touchStartTime = Date()
                            touchStartLocation = value.startLocation
                            touchIsLongPress = false
                            currentGestureID = UUID()
                            currentGestureHasFlicked = false
                            let work = DispatchWorkItem {
                                DispatchQueue.main.async {
                                    touchIsLongPress = true
                                    handlePotentialLongPressStart(at: value.startLocation)
                                }
                            }
                            touchLongPressWorkItem?.cancel()
                            touchLongPressWorkItem = work
                            DispatchQueue.global().asyncAfter(deadline: .now() + longPressThreshold, execute: work)
                            handleHoldTouchBegan(at: value.startLocation)
                        } else {
                            fingerLocation = value.location
                        }
                    }
                    .onEnded { value in
                        touchLongPressWorkItem?.cancel()
                        touchLongPressWorkItem = nil
                        let start = touchStartTime ?? Date()
                        let duration = Date().timeIntervalSince(start)
                        let dx = value.location.x - (touchStartLocation?.x ?? value.location.x)
                        let dy = value.location.y - (touchStartLocation?.y ?? value.location.y)
                        let dist = hypot(dx, dy)

                        if touchIsLongPress {
                            handlePotentialLongPressEnd(at: value.location, duration: duration)
                        } else {
                            if dist < 20.0 {
                                handleTap(at: value.location, in: value.startLocation)
                            } else {
                                handleGlobalFlick(dragValue: value, in: geo.size)
                            }
                        }

                        handleHoldTouchEnded(at: value.location)

                        // reset gesture
                        currentGestureID = nil
                        currentGestureHasFlicked = false
                        touchStartTime = nil
                        touchStartLocation = nil
                        touchIsLongPress = false
                    } : nil
            )
            .gesture(
                DragGesture(minimumDistance: 16)
                    .onEnded { value in
                        handleGlobalFlick(dragValue: value, in: geo.size)
                    }
            ) */
            .fileImporter(isPresented: $isShowingImportPicker, allowedContentTypes: [UTType.json, UTType.audio], allowsMultipleSelection: false) { result in
                switch result {
                case .success(let urls):
                    if let url = urls.first { handleImportedFile(url: url) }
                case .failure(let err):
                    importErrorMessage = "Import picker failed: \(err.localizedDescription)"
                }
            }
            // ContentView.swift — inside ContentView { ... } (body's modifier chain)
            .onAppear {
                // Request AppModel to (re)load sheets (async). AppModel will publish bundledSheets when ready.
                appModel.loadBundledSheets()
                // Do not force-copy appModel.bundledSheets here — wait for the published change.
                print("DBG: ContentView.onAppear requested loadBundledSheets")
            }
            .onChange(of: appModel.bundledSheets) { newList in
                // Mirror the authoritative list from AppModel
                bundledSheets = newList as! [(filename: String, sheet: Sheet)]
                print("DBG: ContentView observed appModel.bundledSheets change -> \(bundledSheets.map { $0.filename })")
            }
            .onChange(of: appModel.selectedSheetFilename) { newSel in
                print("DBG: ContentView observed selectedSheetFilename -> \(String(describing: newSel))")
                // Sync your playback lists from the AppModel selection here
                guard let fn = newSel else {
                    // clear state if needed
                    sheetNotesToPlay = []
                    notesToPlay = []
                    clearBackground()
                    return
                }
                if let idx = bundledSheets.firstIndex(where: { $0.filename == fn }) {
                    let sheet = bundledSheets[idx].sheet
                    // set notes/background from sheet
                    sheetNotesToPlay = sheet.notes
                    // replace asNotes() with your project's converter if different
                    notesToPlay = sheet.notes.asNotes()
                    prepareBackgroundIfNeeded(named: sheet.backgroundFilename, forceReload: true)
                } else {
                    print("DBG: ContentView: selected filename not found in local bundledSheets: \(fn)")
                }
            }
        } // GeometryReader
    } // body

    // MARK: - History UI helpers
    private func loadPlayHistory() {
        playHistory = PlayHistoryStorage.load()
    }

    private func appendPlayHistoryRecord() {
        let rec = PlayRecord(date: Date(),
                             sheetFilename: appModel.selectedSheetFilename,
                             sheetTitle: appModel.selectedSheet?.title,
                             score: score,
                             maxCombo: maxCombo,
                             perfectCount: perfectCount,
                             goodCount: goodCount,
                             okCount: okCount,
                             missCount: missCount)
        PlayHistoryStorage.append(rec)
        loadPlayHistory()
    }

    private func historyEntriesForCarousel() -> [PlayRecord] {
        guard !playHistory.isEmpty else { return [] }
        let bestRecord = playHistory.max(by: { $0.maxCombo < $1.maxCombo })
        let recentRecords = playHistory.filter { rec in
            if let b = bestRecord { return rec.id != b.id }
            return true
        }
        var entries: [PlayRecord] = []
        if let b = bestRecord { entries.append(b) }
        entries.append(contentsOf: Array(recentRecords.prefix(9)))
        return entries
    }


    @ViewBuilder

    // Returns AnyView to keep the concrete return type stable across branches.
    // Call like: flickIndicatorView(for: a, now: playheadTime)
    private func flickIndicatorView(for a: ActiveNote, now: Double, useBlur: Bool = false) -> AnyView {
        // Don't draw for hold notes
        if a.isHold { return AnyView(EmptyView()) }

            // timing anchors
            let hit = a.hitTime
            let approach = max(0.001, a.approachDuration)
            let start = hit - 2.0 * approach    // indicator start (user requested)
            let appear = a.spawnTime            // when the visible note appears

            // nothing to draw before start
            if now < start { return AnyView(EmptyView()) }

            // opacity phases:
            // - start <= now < appear: keep 0.1
            // - appear <= now < hit: interpolate 0.3 -> 0.7
            // - now >= hit: 1.0 until cleared (a.isClear -> hide)
            let opacity: Double
            if now < appear {
                opacity = 0.1
            } else if now >= hit {
                opacity = a.isClear ? 0.0 : 1.0
            } else {
                let denom = max(0.0001, hit - appear)
                let raw = (now - appear) / denom // 0..1
                let eased = pow(raw, 0.9)
                let startVal: Double = 0.3
                let endVal: Double = 0.7
                opacity = startVal + (endVal - startVal) * eased
            }

            // overall progress from start..hit (0..1) used for length/scale
            let rawP = min(1.0, max(0.0, (now - start) / max(0.0001, hit - start)))
            let p = pow(rawP, 0.7)

            // geometry: rod-like shape
            // prefer to compute a moving position along the rod path:
            // - if startPosition is valid (non-zero) use lerp from startPosition -> targetPosition
            // - otherwise, place indicator offset from target along angleDegrees
            let tx = a.targetPosition
            let sp = a.startPosition
            var pos = tx
            if sp != .zero {
                pos = CGPoint(
                    x: sp.x + (tx.x - sp.x) * CGFloat(p),
                    y: sp.y + (tx.y - sp.y) * CGFloat(p)
                )
            } else {
                // fallback: offset along the angle away from target (so it "moves in")
                let angleRad = CGFloat(a.angleDegrees) * .pi / 180.0
                let maxOffset: CGFloat = 120.0 // how far the indicator originates from
                let offset = maxOffset * (1.0 - CGFloat(p)) // reduces to 0 at hit
                pos = CGPoint(x: tx.x + cos(angleRad) * offset, y: tx.y + sin(angleRad) * offset)
            }

            // rod dimensions
            let rodLengthDefault: CGFloat = 160.0   // should match your RodView's default length
            let rodThicknessDefault: CGFloat = 10.0 // rod visual thickness
            // length scales with progress so it shortens as it approaches target (or invert as preferred)
            let lengthScale = 0.6 + 0.4 * CGFloat(p) // from 0.6 -> 1.0
            let length = max(40.0, rodLengthDefault * lengthScale)
            let thickness = max(6.0, rodThicknessDefault * (0.6 + 0.4 * CGFloat(p)))

            // rotation
            let rotation = Angle(degrees: a.angleDegrees)

            // Build view
            if useBlur {
                // nicer visual with blur and gradient (heavier)
                let grad = LinearGradient(
                    gradient: Gradient(stops: [
                        .init(color: Color.yellow.opacity(opacity * 0.95), location: 0.0),
                        .init(color: Color.yellow.opacity(opacity * 0.5), location: 0.6),
                        .init(color: Color.yellow.opacity(0.0), location: 1.0)
                    ]),
                    startPoint: .leading,
                    endPoint: .trailing
                )

                let v = RoundedRectangle(cornerRadius: thickness / 2)
                    .fill(grad)
                    .frame(width: length, height: thickness)
                    .rotationEffect(rotation)
                    .position(pos)
                    .scaleEffect(1.0) // already encoded in length/thickness
                    .blur(radius: 6.0 * (1.0 - CGFloat(p))) // small blur
                    .shadow(color: Color.yellow.opacity(opacity * 0.5), radius: 6 * (1.0 - CGFloat(p)))
                    .opacity(opacity)
                    .allowsHitTesting(false)

                return AnyView(v)
            } else {
                // lightweight variant: solid gradient-less rod with opacity + subtle glow
                let grad = LinearGradient(
                    gradient: Gradient(colors: [
                        Color.yellow.opacity(opacity),
                        Color.yellow.opacity(opacity * 0.35),
                        Color.clear
                    ]),
                    startPoint: .leading,
                    endPoint: .trailing
                )

                let v = RoundedRectangle(cornerRadius: thickness / 2)
                    .fill(grad)
                    .frame(width: length, height: thickness)
                    .rotationEffect(rotation)
                    .position(pos)
                    .opacity(opacity)
                    .allowsHitTesting(false)
                    .compositingGroup()
                    .shadow(color: Color.yellow.opacity(0.25 * opacity), radius: 2.0)

                return AnyView(v)
            }
        }
    // MARK: - Audio/engine helpers

    private func prepareAudioEngineIfNeeded(url: URL) {
        if let engine = audioEngine {
            engine.stop(); audioEngine = nil; playerNode = nil; audioFile = nil
        }
        do {
            let file = try AVAudioFile(forReading: url)
            audioFile = file
            let engine = AVAudioEngine()
            let player = AVAudioPlayerNode()
            engine.attach(player)
            engine.connect(player, to: engine.mainMixerNode, format: file.processingFormat)
            try engine.start()
            audioEngine = engine; playerNode = player
            audioSampleRate = file.processingFormat.sampleRate
            print("DBG: prepared audioEngine for \(url.lastPathComponent), sampleRate=\(audioSampleRate)")
        } catch {
            print("DBG: prepareAudioEngine failed:", error)
        }
    }

    private func scheduleAudioStart(atHostTime hostTime: UInt64? = nil) {
        guard let engine = audioEngine, let player = playerNode, let file = audioFile else { return }
        if player.isPlaying { player.stop() }
        var startTime: AVAudioTime? = nil
        if let ht = hostTime { startTime = AVAudioTime(hostTime: ht) }
        player.scheduleFile(file, at: startTime) {
            DispatchQueue.main.async { print("DBG: audio finished (engine)"); /* handle end */ }
        }
        if let st = startTime { audioStartDeviceTime = TimeInterval(st.hostTime) } else { audioStartDeviceTime = TimeInterval(mach_absolute_time()) }
        player.play()
        print("DBG: scheduled audio (engine) at hostTime \(String(describing: audioStartDeviceTime))")
    }

    // MARK: - Background media helpers

    private func bundleURLForMedia(named mediaFilename: String?) -> URL? {
        guard let mediaFilename = mediaFilename, !mediaFilename.isEmpty else { return nil }
        let ext = (mediaFilename as NSString).pathExtension
        let name = (mediaFilename as NSString).deletingPathExtension
        if let url = Bundle.main.url(forResource: name, withExtension: ext.isEmpty ? "png" : ext, subdirectory: "bundled-resources") { return url }
        if let url = Bundle.main.url(forResource: name, withExtension: ext.isEmpty ? "png" : ext) { return url }
        if let c = try? FileManager.default.contentsOfDirectory(at: SheetFileManager.documentsURL, includingPropertiesForKeys: nil, options: []) {
            if let found = c.first(where: { $0.deletingPathExtension().lastPathComponent == name && $0.pathExtension.lowercased() == ext.lowercased() }) { return found }
            if let found = c.first(where: { $0.deletingPathExtension().lastPathComponent == name }) { return found }
        }
        return nil
    }
    // Add inside ContentView { ... } (near other helpers)

    private func prepareBackgroundForSelectedSheet(forceReload: Bool = false) {
        // If AppModel.selectedSheetFilename matches a bundled sheet, apply its background.
        if let fn = appModel.selectedSheetFilename,
           let idx = bundledSheets.firstIndex(where: { $0.filename == fn }) {
            let sheet = bundledSheets[idx].sheet
            prepareBackgroundIfNeeded(named: sheet.backgroundFilename, forceReload: forceReload)
        } else {
            // no selection -> clear background
            clearBackground()
        }
    }
    private func prepareBackgroundIfNeeded(named filename: String?, forceReload: Bool = false) {
        if let player = backgroundPlayer { player.pause(); backgroundPlayerLooper = nil; backgroundPlayer = nil }
        if filename == nil || filename?.isEmpty == true {
            backgroundImage = nil; backgroundFilename = nil; backgroundIsVideo = false; return
        }
        if !forceReload, let cur = backgroundFilename, cur == filename { print("DBG: background already loaded -> skip"); return }
        backgroundImage = nil; backgroundIsVideo = false; backgroundFilename = nil
        guard let filename = filename else { return }
        if let url = bundleURLForMedia(named: filename) {
            let ext = url.pathExtension.lowercased()
            if ["png","jpg","jpeg","heic","heif"].contains(ext) {
                DispatchQueue.global(qos: .userInitiated).async {
                    if let data = try? Data(contentsOf: url), let img = UIImage(data: data) {
                        DispatchQueue.main.async {
                            self.backgroundImage = img; self.backgroundFilename = filename; self.backgroundIsVideo = false
                            print("DBG: background image loaded: \(filename)")
                        }
                    } else {
                        print("DBG: failed to load image at \(url)")
                    }
                }
                return
            } else if ["mp4","mov","m4v"].contains(ext) {
                let item = AVPlayerItem(url: url)
                let queue = AVQueuePlayer(items: [item])
                let looper = AVPlayerLooper(player: queue, templateItem: item)
                queue.isMuted = true
                queue.actionAtItemEnd = .none
                backgroundPlayerLooper = looper; backgroundPlayer = queue; backgroundIsVideo = true; backgroundFilename = filename
                print("DBG: background video prepared: \(filename)")
                return
            }
        }
        if let img = UIImage(named: filename) ?? UIImage(named: (filename as NSString).deletingPathExtension) {
            backgroundImage = img; backgroundFilename = filename; backgroundIsVideo = false
            print("DBG: background loaded via UIImage(named:): \(filename)")
        } else {
            print("DBG: prepareBackgroundIfNeeded: resource not found -> \(filename)")
        }
    }

    private func clearBackground() {
        if backgroundIsVideo {
            backgroundPlayer?.pause(); backgroundPlayerLooper = nil; backgroundPlayer = nil
        }
        backgroundImage = nil; backgroundFilename = nil; backgroundIsVideo = false
    }

    // MARK: - Bundled sheet loader

    private func loadBundledSheets() -> [(filename: String, sheet: Sheet)] {
        var results: [(String, Sheet)] = []
        let decoder = JSONDecoder()
        if let urls = Bundle.main.urls(forResourcesWithExtension: "json", subdirectory: "bundled-sheets"), !urls.isEmpty {
            for url in urls {
                if let data = try? Data(contentsOf: url), let s = try? decoder.decode(Sheet.self, from: data) {
                    results.append((url.lastPathComponent, s))
                }
            }
        }
        if results.isEmpty, let root = Bundle.main.urls(forResourcesWithExtension: "json", subdirectory: nil) {
            for url in root {
                guard !url.lastPathComponent.hasPrefix(".") else { continue }
                if let data = try? Data(contentsOf: url), let s = try? decoder.decode(Sheet.self, from: data) {
                    if !results.contains(where: { $0.0 == url.lastPathComponent }) { results.append((url.lastPathComponent, s)) }
                }
            }
        }
        if let docs = try? FileManager.default.contentsOfDirectory(at: SheetFileManager.documentsURL, includingPropertiesForKeys: nil, options: []) {
            for url in docs where url.pathExtension.lowercased() == "json" {
                if let data = try? Data(contentsOf: url), let s = try? decoder.decode(Sheet.self, from: data) {
                    if !results.contains(where: { $0.0 == url.lastPathComponent }) { results.append((url.lastPathComponent, s)) }
                }
            }
        }
        print("DBG: loadBundledSheets -> found \(results.count) sheets")
        return results
    }

    // MARK: - Game loop

    private func startGameLoopIfNeeded() {
        if gameLoopTimer != nil { return }
        let timer = DispatchSource.makeTimerSource(queue: DispatchQueue.main)
        timer.schedule(deadline: .now(), repeating: .milliseconds(Int(gameLoopInterval * 1000.0)))
        timer.setEventHandler { self.gameLoopTick() }
        gameLoopTimer = timer
        timer.resume()
        print("DBG: gameLoop started")
    }

    private func stopGameLoopIfNeeded() {
        if let t = gameLoopTimer { t.cancel(); gameLoopTimer = nil; print("DBG: gameLoop stopped") }
    }

    // Replace existing gameLoopTick() with this batched implementation
    private func gameLoopTick() {
        // compute current device time once
        let nowDev: TimeInterval = audioPlayer?.deviceCurrentTime ?? Date().timeIntervalSince1970

        // Prepare local working copy to avoid many published updates
        var newActiveNotes = activeNotes // copy snapshot
        var idsToRemove: [UUID] = []

        // Iterate over snapshot indices (we will mutate newActiveNotes)
        for i in (0..<newActiveNotes.count).reversed() {
            var note = newActiveNotes[i]

            // Movement / approach update (unchanged logic but using local 'note')
            let approachStart = note.approachStartDeviceTime ?? note.approachStartWallTime ?? (nowDev - note.approachDuration)
            let approachEnd = note.approachEndDeviceTime ?? note.approachEndWallTime ?? (approachStart + note.approachDuration)

            if nowDev <= approachStart {
                note.position = note.startPosition
                if note.isTap { note.position2 = note.startPosition }
            } else if nowDev >= approachEnd {
                note.position = note.targetPosition
                if note.isTap { note.position2 = note.targetPosition }
            } else {
                let t = max(0.0, min(1.0, (nowDev - approachStart) / max(0.00001, note.approachDuration)))
                let sx = note.startPosition.x; let sy = note.startPosition.y
                let tx = note.targetPosition.x; let ty = note.targetPosition.y
                let nx = sx + (tx - sx) * CGFloat(t)
                let ny = sy + (ty - sy) * CGFloat(t)
                note.position = CGPoint(x: nx, y: ny)
                if note.isTap { note.position2 = note.position }
            }

            // Hold handling: use central loop rather than per-note timers
            if note.isHold {
                let fillDuration = max(0.0, note.approachDuration * settings.holdFillDurationFraction)
                // compute fill end reference
                let fillEndTime = (note.approachStartDeviceTime != nil) ? (note.approachStartDeviceTime! + fillDuration) : (note.approachStartWallTime ?? Date().timeIntervalSince1970 + fillDuration)
                if nowDev < fillEndTime {
                    let fillT = (nowDev - (note.approachStartDeviceTime ?? note.approachStartWallTime ?? nowDev)) / max(0.00001, fillDuration)
                    note.holdFillScale = max(0.0, min(1.0, fillT))
                } else {
                    note.holdFillScale = 1.0
                    if !note.holdStarted {
                        note.holdStarted = true
                        if self.audioPlayer != nil {
                            note.holdStartDeviceTime = self.audioPlayer?.deviceCurrentTime
                            note.holdLastTickDeviceTime = note.holdStartDeviceTime
                        } else {
                            note.holdStartWallTime = Date().timeIntervalSince1970
                            note.holdLastTickDeviceTime = note.holdStartWallTime
                        }
                        // If finger is down near target at this moment, mark pressed
                        if self.isFingerDown, let finger = self.fingerLocation {
                            let d = hypot(note.targetPosition.x - finger.x, note.targetPosition.y - finger.y)
                            if d <= self.hitRadius && !note.holdPressedByUser && !note.holdWasReleased {
                                note.holdPressedByUser = true
                                note.holdPressDeviceTime = note.holdLastTickDeviceTime
                            }
                        }
                    }
                }

                if note.holdPressedByUser && !note.holdWasReleased {
                    let lastTick = note.holdLastTickDeviceTime ?? nowDev
                    let delta = max(0.0, nowDev - lastTick)
                    note.holdLastTickDeviceTime = nowDev
                    note.holdRemainingSeconds = max(0.0, note.holdRemainingSeconds - delta)
                    let total = max(0.0001, note.holdTotalSeconds)
                    note.holdTrim = min(1.0, max(0.0, note.holdRemainingSeconds / total))
                    if note.holdRemainingSeconds <= 0.0001 {
                        // Complete - schedule removal
                        idsToRemove.append(note.id)
                    }
                } else {
                    // If hold expired without user pressing, check miss window
                    var holdEndDev: TimeInterval? = nil
                    if let hed = note.holdEndTime {
                        if let startDev = self.audioStartDeviceTime, self.audioPlayer != nil {
                            holdEndDev = startDev + hed
                        } else if let sd = self.startDate {
                            holdEndDev = sd.timeIntervalSince1970 + hed
                        } else if let hs = note.holdStartDeviceTime {
                            holdEndDev = hs + note.holdTotalSeconds
                        } else if let hs = note.holdStartWallTime {
                            holdEndDev = hs + note.holdTotalSeconds
                        }
                    } else {
                        if let hs = note.holdStartDeviceTime { holdEndDev = hs + note.holdTotalSeconds }
                        else if let hs = note.holdStartWallTime { holdEndDev = hs + note.holdTotalSeconds }
                    }
                    if let hed = holdEndDev {
                        if nowDev - hed > 0.5 && !note.holdPressedByUser {
                            // Mark miss and remove
                            DispatchQueue.main.async {
                                self.missCount += 1; self.combo = 0; self.consecutiveCombo = 0
                                self.showJudgement(text: "MISS", color: .red)
                            }
                            idsToRemove.append(note.id)
                        }
                    }
                }
            }

            // write back to newActiveNotes
            newActiveNotes[i] = note
        } // end loop

        // perform UI updates once on main
        DispatchQueue.main.async {
            self.playheadTime = nowDev
            // remove notes
            if !idsToRemove.isEmpty {
                withAnimation(.easeIn(duration: 0.12)) {
                    for id in idsToRemove {
                        self.activeNotes.removeAll { $0.id == id }
                    }
                }
            } else {
                // assign updated array
                self.activeNotes = newActiveNotes
            }
        }
    }
    

    // MARK: - Spawn / scheduling and playback

    private func startPlayback(in size: CGSize) {
        // inside startPlayback(in size: CGSize) near the beginning:
        prepareBackgroundForSelectedSheet(forceReload: true)
        if let bg = appModel.selectedSheet?.backgroundFilename {
            prepareBackgroundIfNeeded(named: bg, forceReload: true)
        } else {
            clearBackground()
        }

        print("DBG: startPlayback called isPlaying=\(isPlaying) isStopped=\(isStopped)")
        let isResume = self.isStopped && !self.activeNotes.isEmpty
        if !isResume {
            maxCombo = 0; score = 0; combo = 0; perfectCount = 0; goodCount = 0; okCount = 0; missCount = 0; isShowingResults = false
        }
        self.isStopped = false
        guard !isPlaying else { return }

        // resolve audio
        var audioURL: URL? = nil
        if let selected = appModel.selectedSheet, let audioName = selected.audioFilename {
            audioURL = bundleURLForAudio(named: audioName)
        }

        if let url = audioURL {
            do {
                try AVAudioSession.sharedInstance().setCategory(.playback, mode: .default)
                try AVAudioSession.sharedInstance().setActive(true)
            } catch {
                print("DEBUG: audio session err:", error)
            }

            if let p = preparedAudioPlayer, p.url == url {
                audioPlayer = p; preparedAudioPlayer = nil; audioPlayer?.currentTime = 0
            } else {
                do {
                    audioPlayer = try AVAudioPlayer(contentsOf: url)
                    audioPlayer?.prepareToPlay()
                } catch {
                    print("DEBUG: Audio prepare failed:", error); audioPlayer = nil
                }
            }

            if let player = audioPlayer {
                let session = AVAudioSession.sharedInstance()
                let deviceNow = player.deviceCurrentTime
                let leadTime = max(0.05, session.outputLatency + session.ioBufferDuration + 0.02)
                let startAt = deviceNow + leadTime
                player.play(atTime: startAt)
                audioStartDeviceTime = startAt
                if backgroundIsVideo, let bp = backgroundPlayer {
                    DispatchQueue.main.asyncAfter(deadline: .now() + 0.02) { bp.play() }
                }
                currentlyPlayingAudioFilename = url.lastPathComponent
            } else {
                currentlyPlayingAudioFilename = nil; audioStartDeviceTime = nil
            }
        } else {
            currentlyPlayingAudioFilename = nil; audioStartDeviceTime = nil
        }

        // schedule notes (using sheetNotesToPlay)
        isPlaying = true
        stopGameLoopIfNeeded()
        startGameLoopIfNeeded()
        startDate = Date()
        activeNotes.removeAll()
        flickedNoteIDs.removeAll()
        scheduledWorkItems.forEach { $0.cancel() }; scheduledWorkItems.removeAll()
        autoDeleteWorkItems.values.forEach { $0.cancel() }; autoDeleteWorkItems.removeAll()

        print("startPlayback: scheduling \(sheetNotesToPlay.count) notes")
        for note in sheetNotesToPlay {
            // compute spawn times
            
            let nx = note.normalizedPosition.x
            let ny = note.normalizedPosition.y
            if nx.isNaN || ny.isNaN || nx.isInfinite || ny.isInfinite { continue }
            let clampedX = min(max(0.0, nx), 1.0)
            let clampedY = min(max(0.0, ny), 1.0)
            let approachDistance = settings.approachDistanceFraction * min(size.width, size.height)
            let approachDuration = approachDistance / max(settings.approachSpeed, 1.0)
            let spawnTime = max(0.0, note.time - approachDuration)
            let target = CGPoint(x: clampedX * size.width, y: clampedY * size.height)
            let theta = CGFloat(note.angleDegrees) * .pi / 180.0
            let rodDir = CGPoint(x: cos(theta), y: sin(theta))
            let n1 = CGPoint(x: -rodDir.y, y: rodDir.x)
            let startPos = CGPoint(x: target.x - n1.x * approachDistance, y: target.y - n1.y * approachDistance)

            let newID = UUID()
            let spawnWork = DispatchWorkItem {
                DispatchQueue.main.async {
                    // spawn ActiveNote
                    
                    let isTapNote = (note.noteType == "tap")
                    let isHoldNote = (note.noteType == "hold")
                    if isTapNote {
                        let triangleH = 44.0
                        let halfSeparation = triangleH / 2.0
                        let finalTop = CGPoint(x: target.x, y: target.y - halfSeparation)
                        let finalBottom = CGPoint(x: target.x, y: target.y + halfSeparation)
                        scheduledNoteInfos[newID] = (sheetNote: note, target: target, approachDuration: approachDuration, spawnTime: spawnTime, clearTime: note.time)
                        let topStart = CGPoint(x: finalTop.x, y: finalTop.y - approachDistance * 0.5 - 20.0)
                        let bottomStart = CGPoint(x: finalBottom.x, y: finalBottom.y + approachDistance * 0.5 + 20.0)
                        let new = ActiveNote(id: newID, sourceID: note.id, angleDegrees: 0.0, position: topStart, targetPosition: CGPoint(x: target.x, y: target.y), hitTime: note.time, spawnTime: spawnTime, isClear: false, isTap: true, position2: bottomStart)
                        self.activeNotes.append(new)
                        if let idx = self.activeNotes.firstIndex(where: { $0.id == newID }) {
                            withAnimation(.linear(duration: approachDuration)) {
                                self.activeNotes[idx].position = finalTop
                                self.activeNotes[idx].position2 = finalBottom
                            }
                        }
                    } else if isHoldNote {
                        let nowDev = audioPlayer?.deviceCurrentTime ?? Date().timeIntervalSince1970
                        let approachStartDev = (audioPlayer != nil && audioStartDeviceTime != nil) ? (audioStartDeviceTime! + spawnTime) : (Date().timeIntervalSince1970 + spawnTime)
                        let approachEndDev = approachStartDev + approachDuration
                        var new = ActiveNote(id: newID, sourceID: note.id, angleDegrees: note.angleDegrees, position: startPos, targetPosition: target, hitTime: note.time, spawnTime: spawnTime, isClear: false)
                        new.startPosition = startPos
                        new.approachStartDeviceTime = (audioPlayer != nil) ? approachStartDev : nil
                        new.approachStartWallTime = (audioPlayer == nil) ? Date().timeIntervalSince1970 + spawnTime : nil
                        new.approachEndDeviceTime = (audioPlayer != nil) ? approachEndDev : nil
                        new.approachEndWallTime = (audioPlayer == nil) ? (Date().timeIntervalSince1970 + spawnTime + approachDuration) : nil
                        new.approachDuration = approachDuration
                        new.isHold = true
                        new.holdFillScale = 0.0
                        new.holdTrim = 1.0
                        new.holdTotalSeconds = max(0.0, (note.holdEndTime ?? note.time) - note.time)
                        new.holdRemainingSeconds = new.holdTotalSeconds
                        self.activeNotes.append(new)
                        if let idx = self.activeNotes.firstIndex(where: { $0.id == newID }) {
                            withAnimation(.linear(duration: approachDuration)) {
                                self.activeNotes[idx].position = target
                                self.activeNotes[idx].position2 = target
                            }
                        }
                        let fillDur = max(0.0, approachDuration * max(0.0, min(2.0, settings.holdFillDurationFraction)))
                        DispatchQueue.main.asyncAfter(deadline: .now() + fillDur) {
                            guard let idx2 = self.activeNotes.firstIndex(where: { $0.id == newID }) else { return }
                            self.activeNotes[idx2].holdStarted = true
                            if let p = self.audioPlayer { self.activeNotes[idx2].holdStartDeviceTime = p.deviceCurrentTime }
                            else { self.activeNotes[idx2].holdStartWallTime = Date().timeIntervalSince1970 }
                            if self.isFingerDown, let finger = self.fingerLocation {
                                let d = hypot(self.activeNotes[idx2].targetPosition.x - finger.x, self.activeNotes[idx2].targetPosition.y - finger.y)
                                if d <= self.hitRadius && !self.activeNotes[idx2].holdPressedByUser && !self.activeNotes[idx2].holdWasReleased {
                                    self.activeNotes[idx2].holdPressedByUser = true
                                    self.activeNotes[idx2].holdPressDeviceTime = self.activeNotes[idx2].holdStartDeviceTime ?? self.activeNotes[idx2].holdStartWallTime
                                    self.activeNotes[idx2].holdLastTickDeviceTime = self.activeNotes[idx2].holdPressDeviceTime
                                }
                            }
                            // create hold timer
                            let timer = DispatchSource.makeTimerSource(queue: DispatchQueue.main)
                            timer.schedule(deadline: .now(), repeating: .milliseconds(33))
                            timer.setEventHandler {
                                guard let idx3 = self.activeNotes.firstIndex(where: { $0.id == newID }) else { timer.cancel(); self.holdTimers[newID] = nil; return }
                                if self.activeNotes[idx3].holdWasReleased { timer.cancel(); self.holdTimers[newID] = nil; return }
                                let nowDev2 = self.audioPlayer?.deviceCurrentTime ?? Date().timeIntervalSince1970
                                let lastTick = self.activeNotes[idx3].holdLastTickDeviceTime ?? nowDev2
                                let delta = max(0.0, nowDev2 - lastTick)
                                self.activeNotes[idx3].holdLastTickDeviceTime = nowDev2
                                if self.activeNotes[idx3].holdPressedByUser {
                                    let newRemaining = max(0.0, self.activeNotes[idx3].holdRemainingSeconds - delta)
                                    self.activeNotes[idx3].holdRemainingSeconds = newRemaining
                                    let total = max(0.0001, self.activeNotes[idx3].holdTotalSeconds)
                                    self.activeNotes[idx3].holdTrim = min(1.0, max(0.0, newRemaining / total))
                                    if newRemaining <= 0.0001 {
                                        timer.cancel(); self.holdTimers[newID] = nil
                                        if self.isStopped {
                                            self.activeNotes[idx3].holdRemainingSeconds = 0.0
                                            self.activeNotes[idx3].holdTrim = 0.0
                                            self.activeNotes[idx3].holdCompletedWhileStopped = true
                                            return
                                        }
                                        self.perfectCount += 1; self.score += 3; self.combo += 1
                                        if self.combo > self.maxCombo { self.maxCombo = self.combo }
                                        self.showJudgement(text: "PERFECT", color: .green)
                                        withAnimation(.easeIn(duration: 0.12)) { self.activeNotes.removeAll { $0.id == newID } }
                                        return
                                    }
                                } else {
                                    var holdEndDev: TimeInterval? = nil
                                    if let startDev = self.audioStartDeviceTime, let hed = self.activeNotes[idx3].holdEndTime { holdEndDev = startDev + hed }
                                    else if let sd = self.startDate, let hed = self.activeNotes[idx3].holdEndTime { holdEndDev = sd.timeIntervalSince1970 + hed }
                                    else if let start = self.activeNotes[idx3].holdStartDeviceTime { holdEndDev = start + self.activeNotes[idx3].holdTotalSeconds }
                                    else if let start = self.activeNotes[idx3].holdStartWallTime { holdEndDev = start + self.activeNotes[idx3].holdTotalSeconds }
                                    if let hed = holdEndDev, nowDev2 - hed > 0.5 && !self.activeNotes[idx3].holdPressedByUser {
                                        if self.isStopped { return }
                                        self.missCount += 1; self.combo = 0; self.consecutiveCombo = 0
                                        self.showJudgement(text: "MISS", color: .red)
                                        timer.cancel(); self.holdTimers[newID] = nil
                                        withAnimation(.easeIn(duration: 0.12)) { self.activeNotes.removeAll { $0.id == newID } }
                                        return
                                    }
                                }
                                // also check hold completion at end time
                                if let idx3 = self.activeNotes.firstIndex(where: { $0.id == newID }), let hed = self.activeNotes[idx3].holdEndTime {
                                    let holdEndDev = (self.audioPlayer != nil && self.audioStartDeviceTime != nil) ? (self.audioStartDeviceTime! + hed) : (self.activeNotes[idx3].holdStartWallTime ?? Date().timeIntervalSince1970 + hed)
                                    if self.activeNotes[idx3].holdPressedByUser && (self.audioPlayer?.deviceCurrentTime ?? Date().timeIntervalSince1970) >= holdEndDev {
                                        timer.cancel(); self.holdTimers[newID] = nil
                                        if self.isStopped { self.activeNotes[idx3].holdRemainingSeconds = 0.0; self.activeNotes[idx3].holdTrim = 0.0; self.activeNotes[idx3].holdCompletedWhileStopped = true; return }
                                        self.perfectCount += 1; self.score += 3; self.combo += 1
                                        if self.combo > self.maxCombo { self.maxCombo = self.combo }
                                        self.showJudgement(text: "PERFECT", color: .green)
                                        withAnimation(.easeIn(duration: 0.12)) { self.activeNotes.removeAll { $0.id == newID } }
                                        return
                                    }
                                }
                            }
                            self.holdTimers[newID] = timer
                            timer.resume()
                        }
                    } else {
                        let new = ActiveNote(id: newID, sourceID: note.id, angleDegrees: note.angleDegrees, position: startPos, targetPosition: target, hitTime: note.time, spawnTime: spawnTime, isClear: false)
                        self.activeNotes.append(new)
                        if let idx = self.activeNotes.firstIndex(where: { $0.id == newID }) {
                            withAnimation(.linear(duration: approachDuration)) {
                                self.activeNotes[idx].position = target
                            }
                        }
                    }

                    // auto-delete miss handler
                    let deleteWork = DispatchWorkItem {
                        DispatchQueue.main.async {
                            guard self.activeNotes.firstIndex(where: { $0.id == newID }) != nil else { self.autoDeleteWorkItems[newID] = nil; return }
                            if self.flickedNoteIDs.contains(newID) { self.autoDeleteWorkItems[newID] = nil; return }
                            if let idx = self.activeNotes.firstIndex(where: { $0.id == newID }), self.activeNotes[idx].isHold {
                                self.autoDeleteWorkItems[newID] = nil; return
                            }
                            withAnimation(.easeIn(duration: 0.18)) { self.activeNotes.removeAll { $0.id == newID } }
                            self.combo = 0; self.consecutiveCombo = 0; self.missCount += 1
                            self.autoDeleteWorkItems[newID] = nil
                            self.showJudgement(text: "MISS", color: .red)
                        }
                    }
                    self.autoDeleteWorkItems[newID] = deleteWork
                    if note.noteType != "hold" { DispatchQueue.main.asyncAfter(deadline: .now() + self.lifeDuration, execute: deleteWork) }
                   
                }
            } // end spawnWork

            let clearWork = DispatchWorkItem {
                DispatchQueue.main.async {
                    var foundIndex: Int? = nil
                    let sheetNoteID = note.id
                    if !sheetNoteID.isEmpty {
                        foundIndex = self.activeNotes.firstIndex(where: { $0.sourceID == sheetNoteID })
                    }
                    if foundIndex == nil { foundIndex = self.activeNotes.firstIndex(where: { $0.hitTime == note.time && $0.targetPosition == CGPoint(x: clamp(note.normalizedPosition.x, 0, 1) * size.width, y: clamp(note.normalizedPosition.y, 0,1) * size.height) }) }
                    if let idx = foundIndex { withAnimation(.easeOut(duration: 0.12)) { self.activeNotes[idx].isClear = true } }
                }
            }

            scheduledWorkItems.append(spawnWork)
            scheduledWorkItems.append(clearWork)

            if let player = audioPlayer, let startDevice = audioStartDeviceTime {
                let deviceNow = player.deviceCurrentTime
                let spawnDeviceTime = startDevice + spawnTime
                let clearDeviceTime = startDevice + note.time
                scheduledNoteInfos[newID] = (sheetNote: note, target: target, approachDuration: approachDuration, spawnTime: spawnTime, clearTime: note.time)
                scheduledSpawnTimes[newID] = spawnDeviceTime
                scheduledClearTimes[newID] = clearDeviceTime
                scheduledSpawnWorkItemsByNote[newID] = spawnWork
                scheduledClearWorkItemsByNote[newID] = clearWork
                let spawnDelay = max(0.0, spawnDeviceTime - deviceNow)
                let clearDelay = max(0.0, clearDeviceTime - deviceNow)
                DispatchQueue.main.asyncAfter(deadline: .now() + spawnDelay, execute: spawnWork)
                DispatchQueue.main.asyncAfter(deadline: .now() + clearDelay, execute: clearWork)
            } else {
                let wallNow = Date().timeIntervalSince1970
                let spawnExecuteAt = wallNow + spawnTime
                let clearExecuteAt = wallNow + note.time
                scheduledNoteInfos[newID] = (sheetNote: note, target: target, approachDuration: approachDuration, spawnTime: spawnTime, clearTime: note.time)
                scheduledSpawnTimes[newID] = spawnExecuteAt
                scheduledClearTimes[newID] = clearExecuteAt
                scheduledSpawnWorkItemsByNote[newID] = spawnWork
                scheduledClearWorkItemsByNote[newID] = clearWork
                DispatchQueue.main.asyncAfter(deadline: .now() + spawnTime, execute: spawnWork)
                DispatchQueue.main.asyncAfter(deadline: .now() + note.time, execute: clearWork)
            }
        } // end for each note

        if let last = notesToPlay.map({ $0.time }).max() {
            let finishDelay = last + lifeDuration + 5.0 // 全ノーツ終了後何秒後に終わるか
            let finishWork = DispatchWorkItem {
                DispatchQueue.main.async {
                    self.isPlaying = false
                    self.scheduledWorkItems.removeAll()
                    self.autoDeleteWorkItems.values.forEach { $0.cancel() }
                    self.autoDeleteWorkItems.removeAll()
                    self.holdTimers.values.forEach { $0.cancel() }
                    self.holdTimers.removeAll()
                    self.activeNotes.removeAll()
                    self.audioPlayer?.stop()
                    GlobalSFX.shared.stopHoldLoop()
                    self.cumulativeCombo += self.maxCombo
                    self.consecutiveCombo += self.maxCombo
                    self.playMaxHistory.append(self.maxCombo)
                    UserDefaults.standard.set(self.cumulativeCombo, forKey: "cumulativeCombo")
                    UserDefaults.standard.set(self.playMaxHistory, forKey: "playMaxHistory")
                    UserDefaults.standard.set(self.consecutiveCombo, forKey: "consecutiveCombo")
                    self.isShowingResults = true
                    if self.audioPlayer?.isPlaying == true { self.audioPlayer?.stop() }
                    self.audioPlayer = nil
                    self.currentlyPlayingAudioFilename = nil
                    self.appendPlayHistoryRecord()
                }
            }
            scheduledWorkItems.append(finishWork)
            DispatchQueue.main.asyncAfter(deadline: .now() + finishDelay, execute: finishWork)
        }
    }

    private func stopPlayback() {
        stopGameLoopIfNeeded()
        if audioPlayer?.isPlaying == true { audioPlayer?.stop() }
        if backgroundIsVideo { backgroundPlayer?.pause(); backgroundPlayerLooper = nil; backgroundPlayer = nil }
        backgroundImage = nil; backgroundIsVideo = false; backgroundFilename = nil
        audioPlayer = nil; currentlyPlayingAudioFilename = nil
        scheduledWorkItems.forEach { $0.cancel() }; scheduledWorkItems.removeAll()
        autoDeleteWorkItems.values.forEach { $0.cancel() }; autoDeleteWorkItems.removeAll()
        holdTimers.values.forEach { $0.cancel() }; holdTimers.removeAll()
        isPlaying = false; startDate = nil
    }

    private func pausePlayback() {
        stopGameLoopIfNeeded()
        guard isPlaying else { print("DBG: pause called but not playing"); return }
        isStopped = true
        if audioPlayer?.isPlaying == true { audioPlayer?.pause() }
        if backgroundIsVideo { backgroundPlayer?.pause() }
        scheduledSpawnWorkItemsByNote.values.forEach { $0.cancel() }; scheduledSpawnWorkItemsByNote.removeAll()
        scheduledClearWorkItemsByNote.values.forEach { $0.cancel() }; scheduledClearWorkItemsByNote.removeAll()
        scheduledWorkItems.forEach { $0.cancel() }; scheduledWorkItems.removeAll()
        autoDeleteWorkItems.values.forEach { $0.cancel() }; autoDeleteWorkItems.removeAll()
        pausedRemainingDelays.removeAll()
        let now = audioPlayer?.deviceCurrentTime ?? Date().timeIntervalSince1970
        for (id, exec) in scheduledSpawnTimes {
            let rem = max(0.0, exec - now)
            var e = pausedRemainingDelays[id] ?? (nil, nil)
            e.spawn = rem; pausedRemainingDelays[id] = e
        }
        for (id, exec) in scheduledClearTimes {
            let rem = max(0.0, exec - now)
            var e = pausedRemainingDelays[id] ?? (nil, nil)
            e.clear = rem; pausedRemainingDelays[id] = e
        }
        scheduledSpawnTimes.removeAll(); scheduledClearTimes.removeAll()
        scheduledNoteInfos.removeAll()
    }

    private func resumePlayback() {
        guard isPlaying && isStopped else { return }
        isStopped = false
        if let player = audioPlayer { player.play() }
        if backgroundIsVideo { backgroundPlayer?.play() }
        let now = audioPlayer?.deviceCurrentTime ?? Date().timeIntervalSince1970
        for (noteID, delays) in pausedRemainingDelays {
            guard let info = scheduledNoteInfos[noteID] else { continue }
            let spawnWork = DispatchWorkItem {
                DispatchQueue.main.async { self.performSpawnNow(for: noteID, with: info) }
            }
            scheduledSpawnWorkItemsByNote[noteID] = spawnWork
            if let spawnRem = delays.spawn {
                DispatchQueue.main.asyncAfter(deadline: .now() + spawnRem, execute: spawnWork)
                scheduledSpawnTimes[noteID] = now + spawnRem
            }
            let clearWork = DispatchWorkItem {
                DispatchQueue.main.async { self.performClearNow(for: noteID, with: info) }
            }
            scheduledClearWorkItemsByNote[noteID] = clearWork
            if let clearRem = delays.clear {
                DispatchQueue.main.asyncAfter(deadline: .now() + clearRem, execute: clearWork)
                scheduledClearTimes[noteID] = now + clearRem
            }
        }
        pausedRemainingDelays.removeAll()
        for (idx, a) in activeNotes.enumerated() {
            if a.isHold && !a.holdWasReleased {
                if holdTimers[a.id] == nil {
                    let newID = a.id
                    let timer = DispatchSource.makeTimerSource(queue: DispatchQueue.main)
                    timer.schedule(deadline: .now(), repeating: .milliseconds(33))
                    timer.setEventHandler {
                        guard let idx2 = self.activeNotes.firstIndex(where: { $0.id == newID }) else { timer.cancel(); self.holdTimers[newID] = nil; return }
                        if self.activeNotes[idx2].holdWasReleased { timer.cancel(); self.holdTimers[newID] = nil; return }
                        let nowDev = self.audioPlayer?.deviceCurrentTime ?? Date().timeIntervalSince1970
                        let lastTick = self.activeNotes[idx2].holdLastTickDeviceTime ?? nowDev
                        let delta = max(0.0, nowDev - lastTick)
                        self.activeNotes[idx2].holdLastTickDeviceTime = nowDev
                        if self.activeNotes[idx2].holdPressedByUser {
                            let newRemaining = max(0.0, self.activeNotes[idx2].holdRemainingSeconds - delta)
                            self.activeNotes[idx2].holdRemainingSeconds = newRemaining
                            let total = max(0.0001, self.activeNotes[idx2].holdTotalSeconds)
                            self.activeNotes[idx2].holdTrim = min(1.0, max(0.0, newRemaining / total))
                            if newRemaining <= 0.0001 {
                                timer.cancel(); self.holdTimers[newID] = nil
                                if self.isStopped { self.activeNotes[idx2].holdRemainingSeconds = 0.0; self.activeNotes[idx2].holdTrim = 0.0; self.activeNotes[idx2].holdCompletedWhileStopped = true; return }
                                self.perfectCount += 1; self.score += 3; self.combo += 1
                                if self.combo > self.maxCombo { self.maxCombo = self.combo }
                                self.showJudgement(text: "PERFECT", color: .green)
                                withAnimation(.easeIn(duration: 0.12)) { self.activeNotes.removeAll { $0.id == newID } }
                                return
                            }
                        } else {
                            // check miss
                        }
                    }
                    self.holdTimers[newID] = timer
                    timer.resume()
                }
            }
        }
    }

    private func performSpawnNow(for noteID: UUID, with info: (sheetNote: SheetNote, target: CGPoint, approachDuration: Double, spawnTime: Double, clearTime: Double)) {
        // replicate the spawn behavior (simplified)
        // This helper can be filled to replicate spawnWork; for now we call startPlayback scheduling path.
        // Implementation left minimal to avoid duplication — spawn was already scheduled in startPlayback.
    }

    private func performClearNow(for noteID: UUID, with info: (sheetNote: SheetNote, target: CGPoint, approachDuration: Double, spawnTime: Double, clearTime: Double)) {
        // replicate clear behavior — mark isClear for matching active note
        if let idx = activeNotes.firstIndex(where: { $0.sourceID == info.sheetNote.id }) {
            withAnimation(.easeOut(duration: 0.12)) { activeNotes[idx].isClear = true }
        }
    }

    // MARK: - Input handling

    private func findNearestNoteId(to loc: CGPoint, within radius: CGFloat = 110.0) -> UUID? {
        var nearest: UUID? = nil; var bestDist = CGFloat.greatestFiniteMagnitude
        for n in activeNotes {
            let d = hypot(n.targetPosition.x - loc.x, n.targetPosition.y - loc.y)
            if d < bestDist && d <= radius { bestDist = d; nearest = n.id }
        }
        return nearest
    }

   /* private func handleHoldTouchBegan(at location: CGPoint) {
        guard !isStopped else { return }
        isFingerDown = true; fingerLocation = location
        let nowDev = audioPlayer?.deviceCurrentTime ?? Date().timeIntervalSince1970
        var closestIdx: Int? = nil; var closestDist = CGFloat.greatestFiniteMagnitude
        for (i, n) in activeNotes.enumerated() {
            guard n.isHold else { continue }
            guard !n.holdWasReleased else { continue }
            guard !n.holdPressedByUser else { continue }
            let d = hypot(n.targetPosition.x - location.x, n.targetPosition.y - location.y)
            if d < closestDist && d <= hitRadius { closestDist = d; closestIdx = i }
        }
        guard let idx = closestIdx else { return }
        if !activeNotes[idx].holdStarted {
            activeNotes[idx].holdPressedByUser = true
            activeNotes[idx].holdPressDeviceTime = nowDev
            activeNotes[idx].holdLastTickDeviceTime = nowDev
            return
        }
        var startTimeRef: TimeInterval?
        if let t = activeNotes[idx].holdStartDeviceTime { startTimeRef = t }
        else if let t = activeNotes[idx].holdStartWallTime { startTimeRef = t }
        else {
            if let player = audioPlayer, let startDev = audioStartDeviceTime { startTimeRef = startDev + activeNotes[idx].hitTime }
            else if let sd = startDate { startTimeRef = sd.timeIntervalSince1970 + activeNotes[idx].hitTime }
        }
        guard let holdStartRef = startTimeRef else {
            activeNotes[idx].holdPressedByUser = true; activeNotes[idx].holdPressDeviceTime = nowDev; activeNotes[idx].holdLastTickDeviceTime = nowDev; return
        }
        let dt = nowDev - holdStartRef
        var judgementText = "OK"; var judgementColor: Color = .white
        if abs(dt) <= perfectWindow { judgementText = "PERFECT"; judgementColor = .green; score += 3 }
        else if (dt >= -goodWindowBefore && dt < -perfectWindow) || (dt > perfectWindow && dt <= goodWindowAfter) { judgementText = "GOOD"; judgementColor = .blue; score += 2 }
        else {
            let tooLateEarly = (dt < -goodWindowBefore) || (dt > goodWindowAfter)
            if tooLateEarly {
                judgementText = "MISS"; judgementColor = .red; missCount += 1
                activeNotes[idx].holdWasReleased = true
                withAnimation(.easeIn(duration: 0.12)) { self.activeNotes.removeAll { $0.id == activeNotes[idx].id } }
                showJudgement(text: judgementText, color: judgementColor)
                return
            } else { judgementText = "OK"; judgementColor = .white; score += 1 }
        }
        combo += 1
        if combo > maxCombo { maxCombo = combo }
        switch judgementText { case "PERFECT": perfectCount += 1; case "GOOD": goodCount += 1; case "OK": okCount += 1; default: break }
        showJudgement(text: judgementText, color: judgementColor)
        GlobalSFX.shared.startHoldLoop()
        activeNotes[idx].holdPressedByUser = true
        activeNotes[idx].holdPressDeviceTime = nowDev
        activeNotes[idx].holdLastTickDeviceTime = nowDev
    }
*/
    // Replace your existing handleHoldTouchBegan(at:) in ContentView.swift with this optimized version.
    // Key optimizations:
    // - Use squared distances to avoid expensive hypot() until the final chosen candidate.
    // - Early skip when dx^2+dy^2 > hitRadius^2 so we skip sqrt for distant notes.
    // - Minimize repeated index lookups by working on a local copy and writing back only when needed.

    private func handleHoldTouchBegan(at location: CGPoint) {
        guard !isStopped else { return }
        isFingerDown = true
        fingerLocation = location

        // obtain current device-relative play time (same as elsewhere)
        let nowDev = audioPlayer?.deviceCurrentTime ?? Date().timeIntervalSince1970

        // Fast nearest-hold search using squared distances
        let r = hitRadius
        let r2 = r * r
        var closestIdx: Int? = nil
        var bestDist2: CGFloat = .greatestFiniteMagnitude

        // iterate indices to avoid copying large ActiveNote objects more than necessary
        for i in activeNotes.indices {
            let n = activeNotes[i]
            // only consider hold notes that are valid targets
            if !n.isHold { continue }
            if n.holdWasReleased { continue }
            if n.holdPressedByUser { continue }

            // prefer targetPosition if available (targetPosition is what we consider the "hit" location)
            let ref = (n.targetPosition != .zero) ? n.targetPosition : n.position
            // compute squared distance (cheap)
            let dx = ref.x - location.x
            let dy = ref.y - location.y
            let dist2 = dx * dx + dy * dy
            // early skip if outside radius (cheap)
            if dist2 > r2 { continue }
            // if better than best, keep
            if dist2 < bestDist2 {
                bestDist2 = dist2
                closestIdx = i
            }
        }

        // If no candidate within hitRadius, bail out quickly
        guard let idx = closestIdx else { return }

        // Work with the chosen note
        // We'll mutate it in-place via index
        var chosen = activeNotes[idx]

        // If the hold hasn't entered "holdStarted" yet, just mark pressed and set times
        if !chosen.holdStarted {
            chosen.holdPressedByUser = true
            chosen.holdPressDeviceTime = nowDev
            chosen.holdLastTickDeviceTime = nowDev
            activeNotes[idx] = chosen
            // Start the hold SFX immediately (keep as-is)
            GlobalSFX.shared.startHoldLoop()
            return
        }

        // Determine reference start time for hold judgement
        var startTimeRef: TimeInterval?
        if let t = chosen.holdStartDeviceTime { startTimeRef = t }
        else if let t = chosen.holdStartWallTime { startTimeRef = t }
        else {
            if let player = audioPlayer, let startDev = audioStartDeviceTime {
                startTimeRef = startDev + chosen.hitTime
            } else if let sd = startDate {
                startTimeRef = sd.timeIntervalSince1970 + chosen.hitTime
            }
        }

        // If we couldn't find a time reference, accept as immediate press (fast path)
        guard let holdStartRef = startTimeRef else {
            chosen.holdPressedByUser = true
            chosen.holdPressDeviceTime = nowDev
            chosen.holdLastTickDeviceTime = nowDev
            activeNotes[idx] = chosen
            GlobalSFX.shared.startHoldLoop()
            return
        }

        // Compute dt relative to hold start reference (cheap arithmetic)
        let dt = nowDev - holdStartRef

        // judgement (keep same windows as before)
        var judgementText = "OK"; var judgementColor: Color = .white
        if abs(dt) <= perfectWindow {
            judgementText = "PERFECT"; judgementColor = .green; score += 3
        } else if (dt >= -goodWindowBefore && dt < -perfectWindow) || (dt > perfectWindow && dt <= goodWindowAfter) {
            judgementText = "GOOD"; judgementColor = .blue; score += 2
        } else {
            let tooLateEarly = (dt < -goodWindowBefore) || (dt > goodWindowAfter)
            if tooLateEarly {
                // Miss: minimal mutation and early return
                judgementText = "MISS"; judgementColor = .red; missCount += 1
                chosen.holdWasReleased = true
                // remove chosen note (animate on main)
                DispatchQueue.main.async {
                    withAnimation(.easeIn(duration: 0.12)) {
                        self.activeNotes.removeAll { $0.id == chosen.id }
                    }
                    self.showJudgement(text: judgementText, color: judgementColor)
                }
                return
            } else {
                judgementText = "OK"; judgementColor = .white; score += 1
            }
        }

        // Update scoring and note state with minimal UI work on main queue
        combo += 1
        if combo > maxCombo { maxCombo = combo }
        switch judgementText { case "PERFECT": perfectCount += 1; case "GOOD": goodCount += 1; case "OK": okCount += 1; default: break }

        // Show judgement and start hold loop
        showJudgement(text: judgementText, color: judgementColor)
      //  GlobalSFX.shared.startHoldLoop() <-これを消したら全く音しなくなったから、他のstartHoldLoopは機能していなさそう。

        // mark pressed and initialize times
        chosen.holdPressedByUser = true
        chosen.holdPressDeviceTime = nowDev
        chosen.holdLastTickDeviceTime = nowDev

        // write back the modified note
        activeNotes[idx] = chosen
    }
    private func handleHoldTouchEnded(at location: CGPoint) {
        guard !isStopped else { return }
        isFingerDown = false; fingerLocation = nil
        let nowDev = audioPlayer?.deviceCurrentTime ?? Date().timeIntervalSince1970
        var pressedIdx: Int? = nil; var pressedDist = CGFloat.greatestFiniteMagnitude
        for (i, n) in activeNotes.enumerated() {
            guard n.isHold else { continue }
            guard n.holdPressedByUser else { continue }
            guard !n.holdWasReleased else { continue }
            let d = hypot(n.targetPosition.x - location.x, n.targetPosition.y - location.y)
            if d < pressedDist { pressedDist = d; pressedIdx = i }
        }
        guard let idx = pressedIdx else { return }
        let note = activeNotes[idx]
        activeNotes[idx].holdWasReleased = true
        activeNotes[idx].holdPressedByUser = false
        activeNotes[idx].holdLastTickDeviceTime = nil
        var holdEndRef: TimeInterval?
        if let player = audioPlayer, let startDev = audioStartDeviceTime, let hed = note.holdEndTime { holdEndRef = startDev + hed }
        else if let sd = startDate, let hed = note.holdEndTime { holdEndRef = sd.timeIntervalSince1970 + hed }
        else {
            if let start = note.holdStartDeviceTime { holdEndRef = start + note.holdTotalSeconds }
            else if let start = note.holdStartWallTime { holdEndRef = start + note.holdTotalSeconds }
        }
        guard let holdEnd = holdEndRef
        else { showJudgement(text: "OK", color: .white)
             return }
        let deltaToEnd = holdEnd - nowDev
        var releaseJudgement = "OK"; var releaseColor: Color = .white
        if deltaToEnd <= 0 { releaseJudgement = "PERFECT"; releaseColor = .green; score += 3; perfectCount += 1 }
        else if deltaToEnd <= holdReleaseGoodWindow { releaseJudgement = "GOOD"; releaseColor = .blue; score += 2; goodCount += 1 }
        else if deltaToEnd <= holdReleaseOkWindow { releaseJudgement = "OK"; releaseColor = .white; score += 1; okCount += 1 }
        else { releaseJudgement = "MISS"; releaseColor = .red; missCount += 1; combo = 0; consecutiveCombo = 0 }
        if releaseJudgement != "MISS" { combo += 1; if combo > maxCombo { maxCombo = combo } }
        showJudgement(text: releaseJudgement, color: releaseColor)
        GlobalSFX.shared.stopHoldLoop()
        GlobalSFX.shared.playTapJudgement(releaseJudgement)
        let noteID = note.id
        if let timer = holdTimers[noteID] { timer.cancel(); holdTimers[noteID] = nil }
        withAnimation(.easeIn(duration: 0.12)) { self.activeNotes.removeAll { $0.id == noteID }
            GlobalSFX.shared.stopHoldLoop()}
    }

    private func handleTap(at location: CGPoint, in _unused: CGPoint) {
        guard !isStopped else { return }
        var elapsed: TimeInterval = 0.0
        if let player = audioPlayer, let startDev = audioStartDeviceTime { elapsed = player.deviceCurrentTime - startDev }
        else if let sd = startDate { elapsed = Date().timeIntervalSince(sd) }
        var candidateIndices: [Int] = []
        for (i, a) in activeNotes.enumerated() {
            guard a.isTap else { continue }
            let earliestAccept = a.hitTime - tapEarliestBeforeHit
            if elapsed < earliestAccept { continue }
            let triangleH = 44.0
            let halfSeparation = triangleH / 2.0
            let finalTop = CGPoint(x: a.targetPosition.x, y: a.targetPosition.y - halfSeparation)
            let finalBottom = CGPoint(x: a.targetPosition.x, y: a.targetPosition.y + halfSeparation)
            let topRect = CGRect(x: finalTop.x - 88/2.0, y: finalTop.y - triangleH/2.0, width: 88, height: triangleH)
            let bottomRect = CGRect(x: finalBottom.x - 88/2.0, y: finalBottom.y - triangleH/2.0, width: 88, height: triangleH)
            if topRect.contains(location) || bottomRect.contains(location) { candidateIndices.append(i); continue }
            let d = hypot(a.targetPosition.x - location.x, a.targetPosition.y - location.y)
            if d <= tapHitRadius { candidateIndices.append(i); continue }
        }
        guard !candidateIndices.isEmpty else { return }
        var bestIdx: Int? = nil; var bestTimeDiff = Double.greatestFiniteMagnitude
        for idx in candidateIndices {
            let note = activeNotes[idx]
            let dt = abs(elapsed - note.hitTime)
            if dt < bestTimeDiff { bestTimeDiff = dt; bestIdx = idx }
        }
        guard let idx = bestIdx else { return }
        let note = activeNotes[idx]
        let dt = elapsed - note.hitTime
        var judgementText = "OK"; var judgementColor: Color = .white
        if abs(dt) <= perfectWindow { judgementText = "PERFECT"; judgementColor = .green; score += 3 }
        else if (dt >= -goodWindowBefore && dt < -perfectWindow) || (dt > perfectWindow && dt <= goodWindowAfter) { judgementText = "GOOD"; judgementColor = .blue; score += 2 }
        else { judgementText = "OK"; judgementColor = .white; score += 1 }
        combo += 1; if combo > maxCombo { maxCombo = combo }
        switch judgementText { case "PERFECT": perfectCount += 1; case "GOOD": goodCount += 1; case "OK": okCount += 1; default: break }
        let noteID = note.id
        if let w = autoDeleteWorkItems[noteID] { w.cancel(); autoDeleteWorkItems[noteID] = nil }
        withAnimation(.easeOut(duration: 0.12)) { self.activeNotes.removeAll { $0.id == noteID } }
        showJudgement(text: judgementText, color: judgementColor)
        GlobalSFX.shared.playTapJudgement(judgementText)
    }

    private func handleFlick(for id: UUID, dragValue: DragGesture.Value, in size: CGSize) {
        guard !isStopped else { return }
        if flickedNoteIDs.contains(id) { return }
        let predicted = dragValue.predictedEndTranslation
        let flickVec = CGPoint(x: predicted.width, y: predicted.height)
        let flickSpeed = hypot(flickVec.x, flickVec.y)
        guard flickSpeed > speedThreshold else { return }
        guard let idx = activeNotes.firstIndex(where: { $0.id == id }) else { return }
        let note = activeNotes[idx]
        let theta = CGFloat(note.angleDegrees) * .pi / 180.0
        let rodDir = CGPoint(x: cos(theta), y: sin(theta))
        let n1 = CGPoint(x: -rodDir.y, y: rodDir.x); let n2 = CGPoint(x: rodDir.y, y: -rodDir.x)
        let dot1 = n1.x * flickVec.x + n1.y * flickVec.y
        let dot2 = n2.x * flickVec.x + n2.y * flickVec.y
        let chosenNormal = (dot1 >= dot2) ? n1 : n2
        let distance = max(size.width, size.height) * 1.5
        let target = CGPoint(x: note.position.x + chosenNormal.x * distance, y: note.position.y + chosenNormal.y * distance)
        if let work = autoDeleteWorkItems[id] { work.cancel(); autoDeleteWorkItems[id] = nil }
        flickedNoteIDs.insert(id)
        var elapsed: TimeInterval = 0.0
        if let player = audioPlayer, let startDev = audioStartDeviceTime { elapsed = player.deviceCurrentTime - startDev } else if let sd = startDate { elapsed = Date().timeIntervalSince(sd) }
        let dt = elapsed - note.hitTime
        var judgementText = "OK"; var judgementColor: Color = .white
        if abs(dt) <= perfectWindow { judgementText = "PERFECT"; judgementColor = .green; score += 3 }
        else if (dt >= -goodWindowBefore && dt < -perfectWindow) || (dt > perfectWindow && dt <= goodWindowAfter) { judgementText = "GOOD"; judgementColor = .blue; score += 2 }
        else { judgementText = "OK"; judgementColor = .white; score += 1 }
        combo += 1; if combo > maxCombo { maxCombo = combo }
        switch judgementText { case "PERFECT": perfectCount += 1; case "GOOD": goodCount += 1; case "OK": okCount += 1; default: break }
        showJudgement(text: judgementText, color: judgementColor)
        GlobalSFX.shared.playFlickJudgement(judgementText)
        let flyDuration = 0.6
        withAnimation(.easeOut(duration: flyDuration)) {
            if let idx2 = activeNotes.firstIndex(where: { $0.id == id }) {
                activeNotes[idx2].position = target
            }
        }
        DispatchQueue.main.asyncAfter(deadline: .now() + flyDuration + 0.05) {
            withAnimation(.easeIn(duration: 0.12)) { self.activeNotes.removeAll { $0.id == id } }
            self.flickedNoteIDs.remove(id)
        }
    }

    private func handleGlobalFlick(dragValue: DragGesture.Value, in size: CGSize) {
        if currentGestureHasFlicked { return }
        currentGestureHasFlicked = true
        let predicted = dragValue.predictedEndTranslation
        let flickVec = CGPoint(x: predicted.width, y: predicted.height)
        let flickSpeed = hypot(flickVec.x, flickVec.y)
        guard !isStopped else { return }
        guard flickSpeed > speedThreshold else { return }
        let start = dragValue.startLocation
        var closestId: UUID? = nil; var closestDist = CGFloat.greatestFiniteMagnitude
        for n in activeNotes {
            let d = hypot(n.position.x - start.x, n.position.y - start.y)
            if d < closestDist { closestDist = d; closestId = n.id }
        }
        if let id = closestId, closestDist <= hitRadius { handleFlick(for: id, dragValue: dragValue, in: size) }
    }

    // MARK: - Utility / UI helpers

    private func showJudgement(text: String, color: Color) {
        lastJudgement = text; lastJudgementColor = color; showJudgementUntil = Date().addingTimeInterval(0.8)
    }

    private func shouldShowJudgement() -> Bool {
        if let until = showJudgementUntil { return Date() <= until }
        return false
    }

    // small helpers for previewing history items
    private func previewAndPlaySheet(at idx: Int) {
        guard bundledSheets.indices.contains(idx) else { return }
        let sheet = bundledSheets[idx].sheet
        if let bg = sheet.backgroundFilename { prepareBackgroundIfNeeded(named: bg, forceReload: true) } else { clearBackground() }
        if let audioName = sheet.audioFilename, let url = bundleURLForAudio(named: audioName) {
            do {
                previewPlayer = try AVAudioPlayer(contentsOf: url)
                previewPlayer?.play()
                isPlaying = true
                Timer.scheduledTimer(withTimeInterval: 0.5, repeats: true) { t in
                    if self.previewPlayer?.isPlaying == false {
                        t.invalidate(); self.isPlaying = false
                    }
                }
            } catch {
                print("DBG: preview audio failed:", error)
            }
        }
    }

    private func previewSheet(at bundledIndex: Int) { previewAndPlaySheet(at: bundledIndex) }

    private func previewAndPlaySheet_stop() { stopPreview() }

    private func stopPreview() {
        if previewPlayer?.isPlaying == true { previewPlayer?.stop() }
        previewPlayer = nil
        if backgroundIsVideo { backgroundPlayer?.pause() }
        backgroundPlayerLooper = nil; backgroundPlayer = nil
        backgroundImage = nil; backgroundFilename = nil; backgroundIsVideo = false
        isPlaying = false
    }

    // MARK: - Audio helpers (bundle)
    private func bundleURLForAudio(named audioFilename: String?) -> URL? {
        guard let audioFilename = audioFilename, !audioFilename.isEmpty else { return nil }
        let ext = (audioFilename as NSString).pathExtension
        let name = (audioFilename as NSString).deletingPathExtension
        if let url = Bundle.main.url(forResource: name, withExtension: ext.isEmpty ? "wav" : ext, subdirectory: "bundled-audio") { return url }
        if let url = Bundle.main.url(forResource: name, withExtension: ext.isEmpty ? "wav" : ext) { return url }
        if let c = try? FileManager.default.contentsOfDirectory(at: SheetFileManager.documentsURL, includingPropertiesForKeys: nil, options: []) {
            if let found = c.first(where: { $0.deletingPathExtension().lastPathComponent == name && $0.pathExtension.lowercased() == ext.lowercased() }) { return found }
            if let found = c.first(where: { $0.deletingPathExtension().lastPathComponent == name }) { return found }
        }
        return nil
    }

    // MARK: - Misc fields referenced by UI sheets
    @State private var isShowingResults: Bool = false
    @State private var isShowingShare: Bool = false
    @State private var shareURL: URL? = nil
    @State private var isShowingImportPicker: Bool = false
    @State private var importErrorMessage: String? = nil

    // MARK: - Helpers
    private func clamp(_ v: Double, _ lo: Double, _ hi: Double) -> Double {
        return min(max(v, lo), hi)
    }
}

// MARK: - Reusable small views

// Replace your ResultsView (or the small results sheet view) with this version.
// Place this inside the same file scope where ResultsView is currently defined.
/*
struct ResultsView: View {
    let score: Int
    let maxCombo: Int
    let perfect: Int
    let good: Int
    let ok: Int
    let miss: Int
    let cumulativeCombo: Int
    let playMaxHistory: [Int]
    let consecutiveCombo: Int

    @Environment(\.dismiss) private var dismiss // <-- reliable dismiss

    var body: some View {
        VStack(spacing: 16) {
            Text("プレイ結果").font(.title).bold()
            HStack { Text("Score:").bold(); Spacer(); Text("\(score)").bold() }
            HStack { Text("Max Combo:").bold(); Spacer(); Text("\(maxCombo)") }
            HStack { Text("PERFECT"); Spacer(); Text("\(perfect)") }
            HStack { Text("GOOD"); Spacer(); Text("\(good)") }
            HStack { Text("OK"); Spacer(); Text("\(ok)") }
            HStack { Text("MISS"); Spacer(); Text("\(miss)") }
            Divider()
            HStack { Text("通算連続コンボ"); Spacer(); Text("\(consecutiveCombo)") }
            HStack { Text("通算コンボ"); Spacer(); Text("\(cumulativeCombo)") }
            Spacer()

            Button(action: {
                // Use environment dismiss to reliably close sheet
                dismiss()
            }) {
                Text("閉じる")
                    .bold()
                    .frame(maxWidth: .infinity)
                    .padding()
                    .background(Color.blue)
                    .foregroundColor(.white)
                    .cornerRadius(8)
            }
            .padding(.top, 8)
        }
        .padding()
    }
} */
// MARK: - Basic shapes

struct RodView: View {
    let angleDegrees: Double
    var body: some View {
        Rectangle()
            .fill(LinearGradient(gradient: Gradient(colors: [Color.white, Color.gray]), startPoint: .leading, endPoint: .trailing))
            .cornerRadius(5)
            .shadow(color: Color.white.opacity(0.2), radius: 4, x: 0, y: 2)
            .rotationEffect(.degrees(angleDegrees))
    }
}

struct TriangleUp: Shape {
    func path(in rect: CGRect) -> Path {
        var p = Path()
        p.move(to: CGPoint(x: rect.midX, y: rect.minY))
        p.addLine(to: CGPoint(x: rect.maxX, y: rect.maxY))
        p.addLine(to: CGPoint(x: rect.minX, y: rect.maxY))
        p.closeSubpath()
        return p
    }
}

struct TriangleDown: Shape {
    func path(in rect: CGRect) -> Path {
        var p = Path()
        p.move(to: CGPoint(x: rect.midX, y: rect.maxY))
        p.addLine(to: CGPoint(x: rect.maxX, y: rect.minY))
        p.addLine(to: CGPoint(x: rect.minX, y: rect.minY))
        p.closeSubpath()
        return p
    }
}

struct Sector: Shape {
    var progress: Double
    func path(in rect: CGRect) -> Path {
        var p = Path()
        let center = CGPoint(x: rect.midX, y: rect.midY)
        let radius = min(rect.width, rect.height) / 2.0
        let startAngle = -Double.pi / 2.0
        let endAngle = startAngle + progress * 2.0 * Double.pi
        p.move(to: center)
        p.addArc(center: center, radius: radius, startAngle: Angle(radians: startAngle), endAngle: Angle(radians: endAngle), clockwise: false)
        p.closeSubpath()
        return p
    }
}

struct HoldView: View {
    let size: CGFloat
    let fillScale: Double
    let trimProgress: Double
    let ringColor: Color
    let fillColor: Color
    var body: some View {
        ZStack {
            Circle().stroke(ringColor, lineWidth: max(3, size * 0.06)).frame(width: size, height: size)
            Circle()
                .fill(fillColor)
                .frame(width: size * CGFloat(max(0.0, fillScale)), height: size * CGFloat(max(0.0, fillScale)))
                .opacity(fillScale > 0.001 ? 1.0 : 0.0)
                .mask(Sector(progress: trimProgress).frame(width: size, height: size))
        }.frame(width: size, height: size)
    }
}

// MARK: - TouchOverlay
// Minimal multi-touch overlay that invokes closures with a synthetic touch id and location.
// Replace with your existing TouchOverlay implementation if you have one.
/*class TouchOverlayView: UIView {
    var onBegan: ((Int, CGPoint) -> Void)?
    var onMoved: ((Int, CGPoint) -> Void)?
    var onEnded: ((Int, CGPoint) -> Void)?

    override init(frame: CGRect) {
        super.init(frame: frame)
        isMultipleTouchEnabled = true
        backgroundColor = .clear
    }
    required init?(coder: NSCoder) { fatalError("Not implemented") }

    override func touchesBegan(_ touches: Set<UITouch>, with event: UIEvent?) {
        for t in touches {
            let id = t.hashValue
            let p = t.location(in: self)
            onBegan?(id, p)
        }
    }
    override func touchesMoved(_ touches: Set<UITouch>, with event: UIEvent?) {
        for t in touches {
            let id = t.hashValue
            let p = t.location(in: self)
            onMoved?(id, p)
        }
    }
    override func touchesEnded(_ touches: Set<UITouch>, with event: UIEvent?) {
        for t in touches {
            let id = t.hashValue
            let p = t.location(in: self)
            onEnded?(id, p)
        }
    }
    override func touchesCancelled(_ touches: Set<UITouch>, with event: UIEvent?) {
        for t in touches {
            let id = t.hashValue
            let p = t.location(in: self)
            onEnded?(id, p)
        }
    }
}*/

// MARK: - ShareSheet helper

// MARK: - Preview
struct ContentView_Previews: PreviewProvider {
    static var previews: some View {
        ContentView().environmentObject(AppModel())
    }
}
